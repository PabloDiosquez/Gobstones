// Construir la funci√≥n lista_est√°IncluidaEn_ que dadas 2 listas que no contienen
// elementos repetidos, describe si la primer lista se encuentra contenida en la segunda
// lista (o sea, todos los elementos de la primera aparecen en la segunda).
// Por ejemplo, las expresiones lista_est√°IncluidaEn_([4,5],[5,3,4,6]) y
// lista_est√°IncluidaEn_([4,5],[2,3,4,6,5]) indican que es verdadero que
// est√° incluida, mientras que lista_est√°IncluidaEn_([4,5,8],[4,3,5,6]) indica
// que es falso que est√© incluida.

function lista_est√°IncluidaEn_(primerLista, segundaLista) {
    /*
        PROP√ìSITO:
            * Indica si la primer lista se encuetra contenida en la segunda lista (o sea, todos los elementos de la primera aparecen en la segunda).
        PAR√ÅMETROS:
            * primerLista: [Elemento]
            * segundaLista: [Elemento]
        TIPO: Booleano
        PRECONDICIONES:
            * Los elementos de las listas dadas deben ser del mismo tipo.
            * Las listas dadas no contienen elementos repetidos.
        OBSERVACIONES:
            * Recorrido de b√∫squeda de los elementos de la primer lista sobre la segunda lista.
    */
    
    elementosPorRecorrer := primerLista

    while (not esVac√≠a(elementosPorRecorrer) && pertenece_A_(primero(elementosPorRecorrer)), segundaLista) {
        elementosPorRecorrer := resto(elementosPorRecorrer)
    }

    return (esVac√≠a(elementosPorRecorrer))
}

// FUNCIONES AUXILIARES üê±‚Äçüèç

function pertenece_A_(elemento, lista) {
    /*
        PROP√ìSITO:
            * Indica si **elemento** pertenece a la lista dada.
        PAR√ÅMETROS:
            * elemento: Elemento
            * lista: [Elemento]
        TIPO: Booleano
        PRECONDICIONES:
            * El elemento dado debe ser del mismo tipo que los elementos de la lista dada.
    */
    
    elementosPorRecorrer := lista

    while (not esVac√≠a(elementosPorRecorrer) && primero(elementosPorRecorrer) /= elemento) {
        elementosPorRecorrer := resto(elementosPorRecorrer)
    }

    return (not esVac√≠a(elementosPorRecorrer))
}