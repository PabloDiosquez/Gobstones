// ATENCI√ìN: No tiene que implementar las primitivas salvo que as√≠ lo indique el enunciado, pero si puede hacer
// uso de ellas para solucionar todos los problemas planteados.

// Primitivas ü§≤üèº

procedure MoverGobsManAl_(direcci√≥n)
// PROP√ìSITO: Mueve a Gobs-Man a la celda vecina en la direcci√≥n ‚Äúdirecci√≥n‚Äù.
// El cabezal queda sobre Gobs-Man.
// PRECONDICI√ìNES:
// * Existe una celda vecina en direcci√≥n ‚Äúdirecci√≥n‚Äù.
// * El cabezal se encuentra sobre Gobs-Man.
// PAR√ÅMETROS:
// * direcci√≥n: Direcci√≥n - Indica hacia d√≥nde se mover√° Gobs-Man.

procedure LlevarGobsManAlBorde_(direcci√≥n)
// PROP√ìSITO: Mueve a Gobs-Man a la celda en el borde hacia la direcci√≥n
// ‚Äúdirecci√≥n‚Äù. El cabezal queda sobre Gobs-Man.
// PRECONDICI√ìNES:
// * El cabezal se encuentra sobre Gobs-Man.
// PAR√ÅMETROS:
// * direcci√≥n: Direcci√≥n - Indica hacia d√≥nde se mover√° Gobs-Man.

// Ejercicio 1)
// Al comenzar un nuevo ‚Äúnivel‚Äù del juego, en cada celda del tablero hay un ‚Äúcoco‚Äù (peque√±os puntos amarillos)
// que son el alimento natural de los seres como Gobs-Man. El objetivo de Gobs-Man es precisamente comerse
// todos los cocos del nivel. Para poder hacer esto, contamos con la siguiente primitiva adicional a las
// anteriores:

procedure ComerCoco()
// PROP√ìSITO: Come el coco que hay en la celda actual.
// PRECONDICIONES:
// * Hay un coco en la celda actual.
// * Gobs-Man est√° en la celda actual.

// Se desea implementar el procedimiento ComerTodosLosCocosDelNivel(), que hace que Gobs-Man se
// coma absolutamente todos los cocos del nivel (tablero). Sabemos, por precondici√≥n de dicho procedimiento,
// que hay un coco en cada celda del tablero (incluida en la que inicia Gobs-Man).

procedure ComerTodosLosCocosDelNivel() {
    /*
        PROP√ìSITO:
            * Comer absolutamente todos los cocos del nivel. GobsMan termina en alguna celda indefinida del tablero.
        PRECONDICIONES:
            * El cabezal se encuentra sobre GobsMan.
            * Hay un coco en cada celda del tablero.
    */
    
    LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)) {
        ComerCoco()
        LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    ComerCoco()
}

procedure LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(direcci√≥nPrincipal, direcci√≥nSecundaria) {
    /*
        PROP√ìSITO:
            * Lleva a GobsMan a la primera celda en un recorrido de direcciones **direcci√≥nPrincipal** y **direcci√≥nSecundaria**.
        PAR√ÅMETROS:
            * direcci√≥nPrincipal: Direcci√≥n
            * direcci√≥nSecundaria: Direcci√≥n
        PRECONDICIONES:
            * GobsMan debe estar en la celda actual.
    */
    LlevarGobsManAlBorde_(opuesto(direcci√≥nPrincipal))
    LlevarGobsManAlBorde_(opuesto(direcci√≥nSecundaria))
}

function myFunction(par√°metro1, par√°metro2) {
    /*
        PROP√ìSITO:
            * Indica si existe una celda siguiente en un recorrido de direcciones **direcci√≥nPrincipal** y **direcci√≥nSecundaria**.
        PAR√ÅMETROS:
            * direcci√≥nPrincipal: Direcci√≥n
            * direcci√≥nSecundaria: Direcci√≥n
        TIPO: Booleano.
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (puedeMover(direcci√≥nPrincipal) || puedeMover(direcci√≥nSecundaria))
}

procedure LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(direcci√≥nPrincipal, direcci√≥nSecundaria) {
    /*
        PROP√ìSITO:
            * Lleva a GosbMan a la siguiente celda en un recorrido de direcciones **direcci√≥nPrincipal** y **direcci√≥nSecundaria**.
        PAR√ÅMETROS:
            * direcci√≥nPrincipal: Direcci√≥n
            * direcci√≥nSecundaria: Direcci√≥n
        PRECONDICIONES:
            * GosbMan est√° en la celda actual.
            * Debe existir una celda siguiente en el recorrido de direcciones dadas.
    */
    
    if(puedeMover(direcci√≥nPrincipal)){
        MoverGobsManAl_(direcci√≥nPrincipal)
    }
    else{
        LlevarGobsManAlBorde_(opuesto(direcci√≥nPrincipal))
        MoverGobsManAl_(direcci√≥nSecundaria)
    }
}

// Ejercicio 2)
// Gobs-Man tambi√©n gusta de comer cerezas. En este caso queremos que Gobs-Man se coma absolutamente
// todas las cerezas del nivel. Ojo, a diferencia de los cocos, las cerezas no est√°n en todas las celdas, sino que
// pueden aparecer en algunas celdas y en otras no, y nunca sabemos al arrancar un nivel en cu√°les celdas
// estar√°n las cerezas. Para implementar esto necesitaremos unas nuevas primitivas:

procedure ComerCereza()
// PROP√ìSITO: Come la cereza que haya en la celda actual.
// PRECONDICIONES:
// * Hay una cereza en la celda actual.
// * Gobs-Man est√° en la celda actual.

function hayCereza()
// PROP√ìSITO: Indica cuando hay una cereza en la celda actual.
// PRECONDICI√ìN: Ninguna.

// Ahora si, implementemos el procedimiento ComerTodasLasCerezasDelNivel(), que hace que Gobs-Man
// se coma todas las cerezas del tablero. Note que los tableros iniciales posibles de este ejercicio no tienen
// cocos, sino que en cada celda puede haber una cereza, o no haber nada.

procedure ComerTodasLasCerezasDelNivel() {
    /*
        PROP√ìSITO:
            * Hace que GobsMan coma todas las cerezas del nivel.
        PRECONDICIONES:
            * El cabezal debe estar sobre GobsMan.
    */

    LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)) {
        ComerCerezaSiHay()
        LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    ComerCerezaSiHay()
}

procedure ComerCerezaSiHay() {
    /*
        PROP√ìSITO:
            * Hace que GobsMan coma la cereza en la celda actual, si hay.
        PRECONDICIONES:
            * GobsMan debe estar en la celda actual.
    */
    if(hayCereza()){
        ComerCereza()
    }
}

// Ejercicio 3)
// Para este ejercicio queremos trabajar sobre niveles que tienen tanto cerezas como cocos. En nuestros tableros iniciales habr√° cocos en todas las celdas, y en algunas habr√° adicionalmente una cereza. Gobs-Man quiere comerse absolutamente todo lo que encuentre en el nivel, y nosotros debemos determinar c√≥mo se realiza entonces el c√≥digo de ComerTodoLoQueSeEncuentreEnElNivel().

procedure ComerTodoLoQueSeEncuentreEnElNivel() {
    /*
        PROP√ìSITO:
            * Hace que GobsMan coma absolutamente todo lo que hay en el nivel (tanto cocos como cerezas).
        PRECONDICIONES:
            * GobsMan debe estar en la celda actual.
            * Hay un coco en cada celda del nivel.
    */
    ComerTodosLosCocosDelNivel()
    ComerTodasLasCerezasDelNivel()
}

// Ejercicio 4)
// El programador del juego ha decidido hacer unos peque√±os retoques a c√≥mo inician los niveles. Ahora, en todas las celdas hay cocos, menos en aquellas donde hay una cereza. Es decir, en cada celda puede, o bien haber una cereza, o bien haber un coco (solo estar√° vac√≠a la celda cuando Gobs-Man se haya comido todo lo de la celda, nunca al inicio del nivel). Debemos entonces volver a realizar ComerTodoLoQueSeEncuentreEnElNivel(), y en este caso, la soluci√≥n no es tan sencilla como en el ejercicio anterior.

// ATENCI√ìN: Note que no dispone de una primitiva ‚ÄúhayCoco‚Äù para solucionar el problema. Si su estrategia est√° realizada utilizando dicha primitiva, entonces es incorrecta.

procedure ComerTodoLoQueSeEncuentreEnElNivel() {
    /*
        PROP√ìSITO:
            * Hace que GobsMan coma absolutamente todo lo que hay en el nivel (tanto cocos como cerezas).
        PRECONDICIONES:
            * GobsMan debe estar en la celda actual.
            * En cada celda del nivel debe haber o bien un coco o bien una cereza, pero no ambos a la vez.
    */
    
    LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)) {
        ComerCerezaSiHaySinoComerCoco()
        LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    ComerCerezaSiHaySinoComerCoco()
}

procedure ComerCerezaSiHaySinoComerCoco() {
    /*
        PROP√ìSITO: 
            * Hace que GobsMan coma la cereza de la celda actual, si es que hay; en caso contrario, GobsMan come el coco.
        PRECONDICIONES:
            * GobsMan debe estar en la celda actual.
            * En la celda actual debe existir o bien un coco o bien una cereza, pero no ambos a la vez.
    */
    if(hayCereza()){
        ComerCereza()
    }
    else{
        ComerCoco
    }
}

// Ejercicio 5)
// Gobs-Man puede toparse en alg√∫n momento con un fantasma. Si lo hace, Gobs-Man sufre un paro card√≠aco
// que la hace morir en la celda en donde vi√≥ el espectro. Sabiendo que existen ahora las siguientes primitivas:

procedure MorirGobsMan()
// PROP√ìSITO: Hace que Gobs-Man muera, dejando su cuerpo en la celda actual.
// PRECONDICIONES:
// * El cabezal se encuentra sobre Gobs-Man

function hayFantasma()
// PROP√ìSITO: Indica cuando hay un fantasma en la celda actual.
// PRECONDICI√ìN: Ninguna.

// ATENCI√ìN: Note que una vez muerto Gobs-Man no puede moverse. Es decir, los procedimientos que mueven
// a Gobs-Man tienen ahora una nueva precondici√≥n: Gobs-Man est√° vivo.

// Se pide entonces hagamos una prueba sobre un nivel vac√≠o (Es decir, en las celdas no hay cocos ni cerezas)
// donde Gobs-Man deber√° moverse desde la celda m√°s al Oeste y al Sur, hacia la celda m√°s al Norte y al Este.
// Se garantiza que en alg√∫n lado del tablero habr√° un fantasma, y Gob-Man debe morir en la celda en donde
// encuentre el mismo. Realice entonces el procedimiento RecorrerNivelMuriendoEnElFantasma().

procedure RecorrerNivelMuriendoEnElFantasma() {
    /*
        PROP√ìSITO:
            * Hace que GobsMan recorra el nivel, muriendo en la celda donde encuentra a un fantasma.
        PRECONDICIONES:
            * GosbMan est√° en la celda actual y se encuentra vivo.
            * Debe haber un fantasma en al menos alguna de las celdas del nivel.
    */
    
    LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while (not hayFantasma()) {
        LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    MorirGobsMan()
}

// Ejercicio 6)
// Si bien hemos logrado que Gobs-Man muera en el lugar correcto, tambi√©n se desea contemplar los niveles en
// donde tal vez no haya un fantasma. Es decir, ahora queremos volver a recorrer el nivel, pero esta vez, no
// tenemos la certeza de que hay un fantasma en el nivel. Si hay uno, Gobs-Man deber√° morir all√≠, sino, Gobs-Man
// deber√° quedar vivo en la √∫ltima celda del recorrido. Realice entonces el procedimiento
// RecorrerNivelMuriendoSiHayFantasma() que solucione dicho problema. 

procedure RecorrerNivelMuriendoSiHayFantasma() {
    /*
        PROP√ìSITO:
            * Hace que GobsMan recorra el nivel, muriendo en caso de encontrarse con un fantasma.
        PRECONDICIONES:
            * GosbMan est√° en la celda actual y se encuentra vivo.
    */

    LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && not hayFantasma()) {
        LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    MorirGobsManSiHayFantasma()
}

procedure MorirGobsManSiHayFantasma() {
    /*
        PROP√ìSITO:
            * Hace que GobsMan muera en la celda actual si hay un fantasma en la misma.
        PRECONDICIONES:
            * GobsMan est√° en la celda actual y se encuentra vivo.
    */
    if(hayFantasma()){
        MorirGobsMan()
    }
}

// Ejercicio 7)
// En este ejercicio queremos integrar todas nuestras soluciones al momento. Aunque probablemente no
// podamos reutilizar el c√≥digo, si podremos reutilizar las ideas de lo que venimos trabajando.
// En este caso, el nivel comienza con un coco en cada celda, menos en las que hay cerezas, y tal vez, alg√∫n
// fantasma en alguna celda del tablero. Gobs-Man debe comer todos los cocos y cerezas que pueda, partiendo
// esta vez de la esquina Norte y Oeste, y yendo hacia el Sur y el Este. Al finalizar el nivel, Gobs-Man debe quedar
// en dicha esquina, si es que no se cruz√≥ con ning√∫n fantasma. Si por el contrario el nivel tiene un fantasma,
// Gobs-Man deber√° comer todo lo que tenga en el camino, hasta que se tope con el espectro, donde morir√° y
// terminar√° el juego. Implemente entonces JugarNivel() que realice lo mencionado.

procedure JugarNivel() {
    /*
        PROP√ìSITO: 
            * Hace que GobsMan recorra el nivel comiendo todos los cocos y las cerezas que pueda, hasta llegar a la √∫ltima celda, a menos que se encuentre con un fantasma en alguna celda, en cuyo caso, muere en dicha celda y el juego finaliza.
        PRECONDICIONES:
            * GobsMan est√° en la celda actual y se encuentra vivo. 
            * Debe haber un coco en cada celda del nivel, menos en aquellas en donde hay cerezas.
    */
    
    LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(Este, Sur)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Sur) && not hayFantasma()) {
        ComerCerezaSiHaySinoComerCoco()
        LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(Este, Sur)
    }
    MorirGobsManSiHayFantasmaSinoComerCerezaOComerCoco()
}

procedure MorirGobsManSiHayFantasmaSinoComerCerezaOComerCoco() {
    /*
        PROP√ìSITO: 
            * GobsMan muere en la celda actual si hay un fantasma. En caso contrario, GobsMan come una cereza o un coco, seg√∫n sea el caso. 
        PRECONDICIONES:
            * GobsMan est√° en la celda actual y se encuentra vivo.
            * En la celda actual hay o bien un fantasma o bien una cereza o bien un coco.
    */
    if(hayFantasma()){
        MorirGobsMan()
    }
    else{
        ComerCerezaSiHaySinoComerCoco()
    }
}

// Ejercicio 8)
// Que pasa si quiero que Gobs-Man ahora recorra en sentido inverso, es decir, partiendo en la esquina Sur y
// Este, y yendo hacia el Norte y el Oeste. ¬øSu soluci√≥n permite cambiar f√°cilmente ese detalle? Si la respuesta
// es negativa, piense alguna forma de lograrlo. Pista, el truco est√° en pasar informaci√≥n a los procedimientos
// que realizan el recorrido celda a celda.

procedure JugarNivel() {
    /*
        PROP√ìSITO: 
            * Hace que GobsMan recorra el nivel comiendo todos los cocos y las cerezas que pueda, hasta llegar a la √∫ltima celda, a menos que se encuentre con un fantasma en alguna celda, en cuyo caso, muere en dicha celda y el juego finaliza.
        PRECONDICIONES:
            * GobsMan est√° en la celda actual y se encuentra vivo. 
            * Debe haber un coco en cada celda del nivel, menos en aquellas en donde hay cerezas.
    */
    
    LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(Oeste, Norte)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Oeste, Norte) && not hayFantasma()) {
        ComerCerezaSiHaySinoComerCoco()
        LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(Oeste, Norte)
    }
    MorirGobsManSiHayFantasmaSinoComerCerezaOComerCoco()
}

// Ejercicio 9)
// Queremos realizar el juego, y probar que funcionen nuestras soluciones, pero el dise√±ador gr√°fico ha
// renunciado y no tenemos vestimentas ni primitivas que nos abstraiga de la representaci√≥n, debemos
// contentarnos con ver bolitas. Por suerte, todas nuestras soluciones anteriores asumen la existencia de ciertos
// procedimientos y funciones primitivas, por lo que bastar√° implementar las mismas para tener andando
// nuestro trabajo previo. Asumiremos la siguiente representaci√≥n:
// ‚óè Gobs-Man estar√° representado por una bolita de color Azul si est√° vivo, y dos, si est√° muerto.
// ‚óè Un coco estar√° representado por una bolita de color Negro.
// ‚óè Una cereza estar√° representada por dos bolitas de color Rojo.
// ‚óè Un fantasma estar√° representado por cinco bolitas de color Verde.
// Se pide entonces implemente cada uno de los procedimientos y funciones primitivas mencionados en esta
// gu√≠a utilizando esta representaci√≥n, y luego pruebe las soluciones que hicimos en papel, en la m√°quina.