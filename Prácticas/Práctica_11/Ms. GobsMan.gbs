// Ms. Gobs-Man es la secuela del popular juego de video argentino desarrollado en Gobstones, Gobs-Man. Ms.
// Gobs-Man incorpora una serie de caracter√≠sticas que se esperan transformen al juego en un √©xito inmediato.
// Esta vez el jugador se pondr√° en la piel de Ms.Gobs-Man, la versi√≥n femenina de nuestro aclamado h√©roe
// comecocos. Como en la primera versi√≥n del juego, el objetivo ser√° lograr que Ms. Gobs-Man se coma todos
// los cocos y las cerezas. Para ello contaremos con todas las primitivas que se presentaron en el primer juego,
// que ahora act√∫an sobre Ms.Gobs-Man, as√≠ como tambi√©n la siguiente, que se agrega a las anteriores:

function hayCoco()
// PROP√ìSITO: Indica cuando hay un coco en la celda actual.
// PRECONDICI√ìNES: Ninguna.

// Esta vez, sin embargo, tanto los cocos como las cerezas otorgar√°n puntaje al jugador.

// Ejercicio 10)
// Dado que el cabezal se encuentra en alguna celda, se espera poder determinar cu√°ntos puntos obtendr√° Ms.
// Gobs-Man si come todo lo que hay en dicha celda. Note que la celda puede tener un coco, una cereza, ambos
// o estar vac√≠a. Un coco otorga a Ms. Gobs-Man 100 puntos, y una cereza otorga 2000 puntos. Escriba la
// funci√≥n: puntajeAObtenerEnCeldaActual() que describe los puntos a obtener en la celda actual.

function puntajeAObtenerEnCeldaActual() {
    /*
        PROP√ìSITO:
            * Describe el puntaje que obtiene Ms. GobsMan si come todo lo que hay la celda actual.
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * La celda puede tener un coco, una cereza, ambos o estar vac√≠a.
            * Un coco otorga 100 puntos y una cereza otorga 2000.
    */
    
    return (choose 2100 when (hayCoco() && hayCereza())
                   2000 when (hayCereza())
                   100  when (hayCoco())
                   0    otherwise 
    )
}

// Ejercicio 11)
// Se nos plantea ahora que adem√°s de cerezas y cocos, las celdas pueden contener frutillas (O fresas, si
// prefiere). Las frutillas otorgan 500 puntos solamente, pero pueden encontrarse en cualquier celda.
// Debe replantear la funci√≥n puntajeAObtenerEnCeldaActual() para tener en cuenta dicha situaci√≥n. Si su
// estrategia anterior fue buena, entonces este cambio no deber√≠a redundar en demasiado trabajo. Si por el
// contrario la soluci√≥n no fue buena, le llevar√° m√°s esfuerzo (Si fuera este √∫ltimo caso, lo invitamos a repensar
// si est√° separando el problema en las subtareas correctas, o ver si puede realizar m√°s). Ah, por cierto, casi se
// nos olvida, tambi√©n cuenta con la primitiva siguiente:

function hayFrutilla()
// PROP√ìSITO: Indica cuando hay una frutilla en la celda actual.
// PRECONDICI√ìNES: Ninguna.

// Atenci√≥n: Piense si su soluci√≥n escala correctamente si hubieran otras tres posibles frutas (ej. naranjas,
// bananas y manzanas)

function puntajeAObtenerEnCeldaActual() {
    /*
        PROP√ìSITO:
            * Describe el puntaje que obtiene Ms. GobsMan si come todo lo que hay la celda actual.
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * La celda puede tener un coco, una cereza, ambos o estar vac√≠a.
            * Un coco otorga 100 puntos y una cereza otorga 2000.
    */
    
    return (choose 2600 when  (hayCoco() && hayCereza() && hayFrutilla())
                   2500 when  (hayCereza() && hayFrutilla())
                   2100 when  (hayCoco() && hayCereza())
                   600  when  (hayCoco () && hayFrutilla())
                   2000 when  (hayCereza())
                   500  when  (hayFrutilla())
                   100  when  (hayCoco())
                   0    otherwise
    )
}

// Ejercicio 12)
// Por cierto, para mostrar esos cuadraditos verdes con los puntos que vimos en los ejemplos anteriores se
// utiliz√≥ una muy √∫til primitiva que nos proporcionaron:

procedure Mostrar_PuntosEnPantalla(cantidadDePuntosAMostrar)
// PROP√ìSITO: Muestra en la pantalla la cantidad de puntos dados como
// argumento.
// OBSERVACI√ìN: Los puntos se muestran como un n√∫mero en un recuadro verde
// en la esquina de la celda.
// PRECONDICI√ìNES:
// * No debe haber elementos para comer en la celda actual.
// * El cabezal se encuentra sobre Ms. Gobs-Man.
// PAR√ÅMETROS:
// * cantidadDePuntosAMostrar: N√∫mero - Los puntos a mostrar en la pantalla.

// Ahora queremos asegurarnos de poder mostrar los puntos correspondientes a lo que Ms. Gobs-Man
// efectivamente vaya a comer en la celda actual.
// Se espera que usted cree el procedimiento ComerLoQueHayEnLaCeldaYMostrarPuntos() que haga que
// Ms. Gobs-Man coma todo lo que hay en la celda en donde est√° parada, y que se muestre en dicha celda los
// puntos que se obtienen tras comer lo que all√≠ hab√≠a.
// Probablemente necesite tambi√©n del procedimiento siguiente como primitiva:

procedure ComerFrutilla()
// PROP√ìSITO: Come la frutilla de la celda actual.
// PRECONDICI√ìNES:
// * Hay una frutilla en la celda actual.
// * El cabezal se encuentra sobre Ms. Gobs-Man

procedure ComerLoQueHayEnLaCeldaYMostrarPuntos() {
    /*
        PROP√ìSITO:
            * Ms. GobsMan come todo lo que hay en la celda actual y se muestra en dicha celda los puntos obtenidos tras comer todo lo que hay ah√≠.
        PRECONDICIONES:
            * Ms. GobsMan debe estar en la celda actual.
    */
    puntajeAObtenerEnLaCeldaActual := puntajeAObtenerEnCeldaActual()
    ComerCocoSiHay()
    ComerCerezaSiHay()
    ComerFrutillaSiHay()
    Mostrar_PuntosEnPantalla(puntajeAObtenerEnLaCeldaActual)
}

procedure ComerCocoSiHay() {
    /*
        PROP√ìSITO:
            * Ms. GobsMan come un coco si hay en la celda actual.
        PRECONDICIONES:
            * Ms. GobsMan est√° en la celda actual.
    */
    if(hayCoco()){
        ComerCoco()
    }
}

procedure ComerCerezaSiHay() {
    /*
        PROP√ìSITO:
            * Ms. GobsMan come una cereza si hay en la celda actual.
        PRECONDICIONES:
            * Ms. GobsMan est√° en la celda actual.
    */
    if(hayCereza()){
        ComerCereza()
    }
}

procedure ComerFrutillaSiHay() {
    /*
        PROP√ìSITO:
            * Ms. GobsMan come una cereza si hay en la celda actual..
        PRECONDICIONES:
            * Ms. GobsMan est√° en la celda actual.
    */
    if(hayFrutilla()){
        ComerFrutilla()
    }
}

// Ejercicio 13)
// Se desea saber cu√°ntos puntos es posible obtener en un nivel determinado. Esto depender√° por supuesto de
// la cantidad de celdas que haya en dicho nivel, as√≠ como de que haya en cada celda (cocos, cerezas, frutillas,
// combinaciones de estas o nada). Se pide entonces realice la funci√≥n cantidadDePuntosEnElNivel()
// que indique la cantidad total de puntos que se pueden obtener en el nivel. Por ejemplo, en el siguiente nivel se
// obtienen 18700 puntos (considerando que en el lugar en donde inicia Ms. Gobs-Man no hay nada). Puede
// asumir que el cabezal se encuentra sobre Ms. Gobs-Man.

// Atenci√≥n: Para calcular los puntos no es necesario mover a Ms. Gobs-Man, sino s√≥lo el cabezal. Sin embargo,
// si movemos a Ms. Gobs-Man tampoco representar√° un problema, pues las funciones no tienen efecto, sino
// que describen valores.

function cantidadDePuntosEnElNivel() {
    /*
        PROP√ìSITO:
            * Describe la cantidad de puntos que se pueden obtener en el nivel dado.
        TIPO: N√∫mero.
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * Recorrido de acumulaci√≥n sobre las celdas del nivel, acumulando la cantidad de puntos que se pueden obtener en cada celda.
    */
    
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    puntajeAlMomento := puntajeAObtenerEnCeldaActual()
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        puntajeAlMomento:= puntajeAlMomento + puntajeAObtenerEnCeldaActual()
    }
    return (puntajeAlMomento)
}

// Ejercicio 14)
// Es interesante poder determinar si Ms. Gobs-Man va a morir a causa de cruzarse con un fantasma o no
// (Recordemos que en un nivel puede o no haber fantasmas). Se desea entonces la funci√≥n
// hayAlg√∫nFantasmaEnElNivel() que indica si hay un fantasma en el nivel. Por cierto, puede asumir que el
// cabezal se encuentra sobre Ms. Gobs-Man.
// Pista: Esta funci√≥n es muy parecida a buscar un fantasma y luego morir, pero en lugar de morir debo indicar si
// encontr√© o no el fantasma. Note que no necesita variables para resolver el problema.

function hayAlg√∫nFantasmaEnElNivel() {
    /*
        PROP√ìSITO:
            * Indica si hay alg√∫n fantasma en el nivel.
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && not hayFantasma()){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    return (hayFantasma())
}


// FUNCIONES AUXILIARES üê±‚Äçüèç

// a.
procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Ubica el cabezal en el inicio de un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n - La primera direcci√≥n del recorrido.
            * dirSecundaria: Direcci√≥n - La segunda direcci√≥n del recorrido.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}

// b.
function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Indica si existe una celda siguiente en un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n - La primera direcci√≥n del recorrido.
            * dirSecundaria: Direcci√≥n - La segunda direcci√≥n del recorrido.
        TIPO: Booleano.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */  
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}

// c.
procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Mueve el cabezal a la siguiente celda de un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n - Describe la primera direcci√≥n del recorrido.
            * dirSecundaria: Direcci√≥n - Describe la segunda direcci√≥n del recorrido.
        PRECONDICIONES:
            * Debe existir al menos una celda siguiente en el recorrido.
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */
    if (puedeMover(dirPrincipal)){
        Mover(dirPrincipal)
    }
    else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}