// Construir las funciones:
// a. n√∫merosParesDe_, que dada una lista de N√∫meros, describa la lista de
// n√∫meros pares que aparecen en la misma.
// Por ejemplo, n√∫merosParesDe_([3,4,5,2,5]) describe [4,2].

function n√∫merosParesDe_(listaDeN√∫meros) {
    /*
        PROP√ìSITO:
            * Dada una lista de n√∫meros, describe la lista de n√∫meros pares que aparecen en la misma.
        PAR√ÅMETROS:
            * listaDeN√∫meros: [N√∫mero].
        TIPO: [N√∫mero].
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    n√∫merosPorMirar := listaDeN√∫meros

    n√∫merosParesHastaAhora := []

    while (not esVac√≠a(n√∫merosPorMirar)) {
        
        n√∫merosParesHastaAhora := n√∫merosParesHastaAhora ++ singular_Si_Vac√≠oSino(primero(n√∫merosPorMirar), esPar_(primero(n√∫merosPorMirar)))

        n√∫merosPorMirar := resto(n√∫merosPorMirar)
    }

    return (n√∫merosParesHastaAhora)
}

// b. laLista_SinElElemento_, que dados una lista y un elemento, describa la
// lista que resulta de quitar todas las apariciones del elemento dado que ocurren
// en lista dada. ¬øDe qu√© tipo debe ser elemento?
// Por ejemplo, laLista_SinElElemento_([Azul,Verde,Azul,Rojo],
// Azul) describe [Verde,Rojo].

function laLista_SinElElemento_(lista, elemento) {
    /*
        PROP√ìSITO:
            * Describe la lista que resulta de quitar todas las apariciones del elemento dado que ocurren en la lista dada.
        PAR√ÅMETROS:
            * lista:    [Elemento].
            * elemento: Elemento.
        TIPO: [Elemento].
        PRECONDICIONES:
            * El elemento dado debe ser del mismo tipo que los elementos de la lista.
    */
    
    elementosPorMirar := lista

    listaSinAparicionesHastaAhora := []

    while (not esVac√≠a(elementosPorMirar)) {

        listaSinAparicionesHastaAhora := listaSinAparicionesHastaAhora ++ singular_Si_Vac√≠oSino(primero(elementosPorMirar), primero(elementosPorMirar) /= elemento)

        elementosPorMirar := resto(elementosPorMirar)
    } 

    return (listaSinAparicionesHastaAhora)
}

// FUNCIONES AUXILIARES üê±‚ÄçüöÄ

function singular_Si_Vac√≠oSino(elemento, condici√≥n) {
    /*
        PROP√ìSITO: 
            * Describe la lista formada √∫nicamente por el elemento dado si la condici√≥n dada es verdadera; en caso contrario, describe la lista vac√≠a.
        PAR√ÅMETROS:
            * elemento:  Elemento.
            * condici√≥n: Booleano.
        TIPO: [Elemento].
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose [elemento] when (condici√≥n)
                   []         otherwise 
        )
}

function esPar_(n√∫mero) {
    /*
        PROP√ìSITO:
            * Indica si el n√∫mero dado es par.
        PAR√ÅMETROS:
            * n√∫mero: N√∫mero.
        TIPO: Booleano.
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (n√∫mero mod 2 == 0)
}