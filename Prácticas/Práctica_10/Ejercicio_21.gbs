// Construir la funci√≥n sinLaPrimeraAparici√≥nDe_en_ que dado un elemento y una
// lista, describe la lista que se obtiene de eliminar una √∫nica vez el elemento, si es que
// este aparece en la lista.
// Por ejemplo, sinLaPrimeraAparici√≥nDe_en_(8,[4,8,42,15,8,42]) describe
// [4,42,15,8,42] y sinLaPrimerAparici√≥nDe_en_(42,[4,8,42,15,8,42])
// describe [4,8,15,8,42].

function sinLaPrimeraAparici√≥nDe_en_(elementoBuscado, lista) {
    /*
        PROP√ìSITO:
            * Describe la lista que se obtiene de eliminar una √∫nica vez el elemento dado de la lista dada, si es que √©ste aparece en la misma.
        PAR√ÅMETROS:
            * elemento: Elemento
            * lista: [Elemento]
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */

    return (
        choose subListaDe_Hasta_(lista, posici√≥nDe_enLaQueAparece_(lista, elementoBuscado)) ++
        subListaDe_Desde_(lista, posici√≥nDe_enLaQueAparece_(lista, elementoBuscado)) when (contiene_A_(lista, elementoBuscado))
        
        lista otherwise
    )

}

// FUNCIONES AUXILIARES üê±‚Äçüèç

function subListaDe_Hasta_(lista, posici√≥n) {
    /*
        PROP√ìSITO:
            * Describe la sublista formada por todos los elementos de la lista dada desde el primero hasta la posici√≥n **posici√≥n** sin incluir.
        PAR√ÅMETROS:
            * lista: [Elemento]
            * posici√≥n: N√∫mero
        TIPO: [Elemento]
        PRECONDICIONES:
            * **posici√≥n** debe ser >= 0.
            * **posici√≥n** debe ser menor o igual a la longitud de la lista.
    */
    
    elementosPorRecorrer := lista

    posici√≥nActual := 0

    listaDeElementosHasta := [] 

    while(posici√≥nActual < posici√≥n){
        listaDeElementosHasta := listaDeElementosHasta ++ [primero(elementosPorRecorrer)]

        elementosPorRecorrer := resto(elementosPorRecorrer)

        posici√≥nActual := posici√≥nActual + 1
    }

    return (listaDeElementosHasta)
}

function subListaDe_Desde_(lista, posici√≥n) {
    /*
        PROP√ìSITO:
            * Describe la sublista formada por todos los elementos de la lista dada desde la posici√≥n **posici√≥n** sin incluirla.
        PAR√ÅMETROS:
            * lista: [Elemento]
            * posici√≥n: N√∫mero
        TIPO: [Elemento]
        PRECONDICIONES:
            * **posici√≥n** debe ser > -1.
            * **posici√≥n** debe ser menor a la longitud de la lista.
    */
    
    subListaAlMomento := lista

    repeat (posici√≥n+1) {
        subListaAlMomento := resto(subListaAlMomento)
    }

    return (subListaAlMomento)
}

function posici√≥nDe_enLaQueAparece_(lista, elemento) {
    /*
        PROP√ìSITO:
            * Describe la posici√≥n en la que aparece por primera vez, el elemento dado en la lista dada. 
        PAR√ÅMETROS:
            * elemento: Elemento
            * lista: [Elemento]
        TIPO: N√∫mero
        PRECONDICIONES:
            * El elemento dado debe aparecer al menos una vez en la lista.
    */

    elementosPorRecorrer := lista

    posici√≥nAlMomento := 0
    
    while (primero(elementosPorRecorrer) /= elemento) {
        posici√≥nAlMomento := posici√≥nAlMomento + 1

        elementosPorRecorrer := resto(elementosPorRecorrer)
    }

    return (posici√≥nAlMomento)
}

function contiene_A_(lista, elemento) {
    /*
        PROP√ìSITO:
            * Indica si la lista dada contiene al elemento dado.
        PAR√ÅMETROS:
            * lista:   [Elemento]
            * elemento: Elemento
        TIPO: Booleano.
        OBSERVACIONES:
            * Recorrido de b√∫squeda sobre la lista dada, buscando el elemento dado.
    */
    
    elementosPorMirar := lista

    while (not esVac√≠a(elementosPorMirar) && primero(elementosPorMirar) /= elemento) {
        elementosPorMirar := resto(elementosPorMirar)
    }

    return (not esVac√≠a(elementosPorMirar))
}

function singular_Si_(elemento, condici√≥n) {
    /*
        PROP√ìSITO: 
            * Describe la lista formada √∫nicamente por el elemento dado si se cumple la condici√≥n dada; en caso contrario, describe la lista vac√≠a.
        PAR√ÅMETROS:
            * elemento: Elemento
            * condici√≥n: Booleano
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose [elemento] when (condici√≥n) 
                    []    otherwise)
}