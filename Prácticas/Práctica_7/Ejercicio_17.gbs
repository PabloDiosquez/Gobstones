// El casino, parte 2
// En el marco del ejercicio del casino de la práctica 6, escribir las siguientes
// operaciones. En cada caso, recordar escribir primero el contrato, y expresar la
// estrategia usando subtareas (preferentemente con la metodología top-down).
// a. estáElJugador_(nroJugador), que denota verdadero si el jugador
// indicado tiene registrada, al menos, una apuesta.
// b. alguienJugóA_MasDe_(nroApostado, cantidadMínima), que denota
// verdadero si algún jugador apostó al número indicado por un monto mayor a
// cantidadMínima.

// a.

function estáElJugador_(nroJugador) {
    /*
        PROPÓSITO:
            * Indica si el jugador **nroJugador** tiene registrada, al menos una apuesta.
        PARÁMETROS:
            * nroJugador: Número - Es el número del jugador a buscar en la mesa de apuestas actual.
        TIPO: Booleano.
        PRECONDICIONES:
            * Debe haber una representación válida de una mesa de apuestas en el tablero.
            * **nroJugador** debe ser mayor o igual a cero.
        OBSERVACIONES:
            * Recorrido de búsqueda por celdas.
    */

    estáElJugador := estáElJugadorNro_EnLaCeldaActual(nroJugador)

    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este,Norte)

    while (not estáElJugador && haySiguienteCeldaEnUnRecorridoAl_Y_(Este,Norte)) {
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este,Norte)
        estáElJugador := estáElJugadorNro_EnLaCeldaActual(nroJugador)
    }

    return (estáElJugador)
}

function estáElJugadorNro_EnLaCeldaActual(nroJugador) {
    /*
        PROPÓSITO:
            * Indica si el jugador **nroJugador** está en la celda actual.
         PARÁMETROS:
            * nroJugador: Número - Es el número del jugador a buscar en la celda actual.
        TIPO: Booleano.
        PRECONDICIONES:
            * La celda actual debe, o bien tener una representación válida de una apuesta o bien estar vacía.
            * **nroJugador** debe ser mayor o igual a cero.
    */
    
    return (nroJugador() == nroJugador)
}

procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}

// b.
function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
    */  
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}

// c.
procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
    */
    if (puedeMover(dirPrincipal)){
        Mover(dirPrincipal)
    }
    else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}