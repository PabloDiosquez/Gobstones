// Algunas funciones sobre listas

// 1.

function cons(elemento, lista) {
    /*
        PROP√ìSITO:
            * Describe la lista que resulta de agregar **elemento** a la lista dada, adelante de todos los dem√°s.
        PAR√ÅMETROS:
            * elemento: Elemento
            * lista   : [Elemento]
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return ([elemento] ++ lista)
}

// 2.

function snoc(lista, elemento) {
    /*
        PROP√ìSITO:
            * Describe la lista que resulta de agregar **elemento** a la lista dada, al final de todos los dem√°s.
        PAR√ÅMETROS:
            * lista    : [Elemento]
            * elemento : Elemento
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una fucni√≥n total).
    */
    
    return (lista ++ [elemento])
}

// 3.

function secuenciaAritm√©ticaDeN√∫merosDe_A_(valorInicial, valorFinal) {
    /*
        PROP√ìSITO:
            * Describe una lista que tiene todos los n√∫meros desde **valorInicial** hasta **valorFinal**.
        PAR√ÅMETROS:
            * valorInicial: N√∫mero.
            * valorFinal  : N√∫mero.
        TIPO: [N√∫mero].
        PRECONDICIONES:
            * El valor incial dado debe ser <= que el valor final dado.
        OBSERVACIONES:
            * Recorrido de acumulaci√≥n de listas.
    */
        
    pr√≥ximoN√∫mero := valorInicial

    listaHastaAhora := []

    while (pr√≥ximoN√∫mero <= valorFinal) {
        
        listaHastaAhora := listaHastaAhora ++ [pr√≥ximoN√∫mero]

        pr√≥ximoN√∫mero := pr√≥ximoN√∫mero + 1
    }

    return (listaHastaAhora)
}

// 4.

function enTotal_IgualesA_(cantidad, elemento) {
    /*
        PROP√ìSITO:
            * Describe una lista con **cantidad** de elementos iguales a **elemento**.
        PAR√ÅMETROS:
            * cantidad: N√∫mero.
            * elemento: Elemento.
        TIPO: [Elemento]
        PRECONDICIONES:
            * La cantidad dada debe ser >= 0.
    */
    
    listaHastaAhora := []

    repeat (cantidad) {
        
        listaHastaAhora := [elemento ]++ listaHastaAhora
    }

    return (listaHastaAhora)
}

// 5.

function filaActual() {
    /*
        PROP√ìSITO:
            * Describe la fila actual del tablero como una lista de celdas.
        TIPO: [Celda]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    filaProcesada := []

    IrAlBorde(Oeste)

    while (puedeMover(Este)) {
        filaProcesada := filaProcesada ++ [celdaActual()]

        Mover(Este)
    }

    return (filaProcesada ++ [celdaActual()])
}

// 6.

function tableroActual() {
    /*
        PROP√ìSITO:
            * Describe el tablero actual como una lista de listas de celdas..
        TIPO: [[Celda]]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    tableroProcesado := []

    IrAlBorde(Norte)

    while (puedeMover(Sur)) {
        tableroActual := tableroActual ++ [filaActual()]

        Mover(Sur)
    }

    return (tableroProcesado ++ [filaActual()])
}

// üîπ PRIMITIVAS

// ¬øC√≥mo obtenemos informaci√≥n de una lista? ‚óè Precisamos acceder a sus elementos‚Ä¶ ‚óã¬°Funciones sobre listas! 
// ¬øCu√°l es el conjunto m√≠nimo de expresiones primitivas que resulta m√°s conveniente tener para construir esas funciones?

// Un conjunto adecuado de primitivas debe permitir crear todas las dem√°s operaciones que se deseen 
// El siguiente conjunto cumple esa condici√≥n: 
//primero(<expLista>) 
//resto(<expLista>) (en bloques: ‚ÄúsinElPrimero_‚Äù) 
//esVac√≠a(<expLista>) (en bloques: ‚Äú¬øest√°Vac√≠a_?‚Äù)

// primero(<expLista>) 
// PROP√ìSITO: describir el primer elemento de la lista dada 
// PRECONDICI√ìN: la lista dada no es vac√≠a 
// PAR√ÅMETRO: la lista es de un tipo Lista cualquiera 
// TIPO: el tipo de los elementos de la lista dada

// resto(<expLista>)
// PROP√ìSITO: describir una lista con los elementos de la lista dada, excepto que sin el primero de ellos PRECONDICI√ìN: la lista dada no es vac√≠a 
// PAR√ÅMETRO: la lista es de un tipo Lista cualquiera 
// TIPO: el tipo de la lista dada

// esVac√≠a(<expLista>) 
// PROP√ìSITO: indicar si la lista es vac√≠a 
// PRECONDICI√ìN: ninguna 
// PAR√ÅMETRO: la lista es de un tipo Lista cualquiera 
// TIPO: Booleano

// 7.

function segundo(lista) {
    /*
        PROP√ìSITO:
            * Describe el segundo elemento de la lista dada.
        PAR√ÅMETROS:
            * lista: [Elemento].
        TIPO: Elemento.
        PRECONDICIONES:
            * La lista dada debe tener al menos dos elementos.
    */
    
    return (primero(resto(lista)))
}

// 8.

function sinLosDosPrimeros(lista) {
    /*
        PROP√ìSITO: 
            * Describe la lista que resulta de quitar los dos primeros elementos de la lista dada.
        PAR√ÅMETROS:
            * lista: [Elemento].
        TIPO: [Elemento]
        PRECONDICIONES:
            * La lista dada debe tener al menos dos elementos.
    */
    
    return (resto(resto(lista)))
}