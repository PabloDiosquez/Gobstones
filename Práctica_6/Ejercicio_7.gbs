// BIBLIOTECA Escribir los procedimientos necesarios para generalizar la noción de
// recorrido por celdas de un tablero, para que las direcciones de recorrido no estén
// fijas. En particular, definir (como siempre, comenzando por los contratos):
// a. IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
// b. haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
// c. IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria)
// Al escribir las precondiciones, tener en cuenta que las direcciones no pueden ser
// cualesquiera, sino que deben estar relacionadas… ¿Cuál es esa relación? ¿Cómo
// expresarla?

// a.
procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROPÓSITO:
            * Ubica el cabezal en el inicio de un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PARÁMETROS:
            * dirPrincipal: Dirección - Describe la primera dirección del recorrido.
            * dirSecundaria: Dirección - Describe la segunda dirección del recorrido.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}

// b.
function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROPÓSITO:
            * Indica si existe una celda siguiente en un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PARÁMETROS:
            * dirPrincipal: Dirección - Describe la primera dirección del recorrido.
            * dirSecundaria: Dirección - Describe la segunda dirección del recorrido.
        TIPO: Booleano.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */  
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}