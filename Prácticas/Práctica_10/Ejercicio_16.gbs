// Construir las funciones:
// a. intersecci√≥nDe_Con_, que dadas dos listas que no contienen elementos
// repetidos, describe la lista de todos los elementos que aparecen en ambas.
// Por ejemplo: intersecci√≥nDe_Con_([1,3,4], [2,4,3,5]) describe
// [3,4].
// b. uni√≥nDe_Con_, que dadas dos listas que no contienen elementos repetidos,
// describe una lista sin repetidos que contenga todos los elementos que aparecen
// en alguna de las 2 listas.
// Por ejemplo, uni√≥nDe_Con_([1,3,4],[2,4,3,5]) describe [1,3,4,2,5].
// ¬øDe qu√© tipo es la primera lista? ¬øY la segunda? ¬øPueden ser de tipos
// diferentes?

// a.
function intersecci√≥nDe_Con_(lista1, lista2) {
    /*
        PROP√ìSITO: 
            * Describe la lista de todos los elementos que aparecen en las dos listas dadas.
        PAR√ÅMETROS:
            * lista1: [Elemento]
            * lista2: [Elemento]
        TIPO: [Elemento]
        PRECONDICIONES:
            * Los elementos de la lista dada deben ser del mismo tipo.
            * Las listas dadas no contienen elementos repetidos.
    */

    intersecci√≥nAlMomento := []

    foreach elemento in lista1 {
        intersecci√≥nAlMomento := intersecci√≥nAlMomento ++
                 singular_Si_(elemento, pertenece_A_(elemento, lista2))
    }
    
    return (intersecci√≥nAlMomento)
}

// b.
function uni√≥nDe_Con_(lista1, lista2) {
    /*
        PROP√ìSITO: 
            * Describe una lista sin repetidos que contiene a todos los elementos que aparecen en alguna de las 2 listas dadas.
        PAR√ÅMETROS:
            * lista1: [Elemento]
            * lista2: [Elemento]
        TIPO: [Elemento]
        PRECONDICIONES:
            * Los elementos de la lista dada deben ser del mismo tipo.
            * Las listas dadas no contienen elementos repetidos.
    */
    
    uni√≥nAlMomento := lista1

    foreach elemento in lista2 {
        uni√≥nAlMomento := uni√≥nAlMomento ++ singular_Si_(elemento, not pertenece_A_(elemento, uni√≥nAlMomento))
    }
    
    return (uni√≥nAlMomento)
}

// FUNCIONES AUXILIARES üê±‚Äçüèç

function singular_Si_(elemento, condici√≥n) {
    /*
        PROP√ìSITO:
            * Describe una lista formada √∫nicamente por el elemento dado si la condici√≥n dada es verdadera; caso contrario, describe la lista vac√≠a.
        PAR√ÅMETROS:
            * elemento: Elemento
            * condici√≥n: Booleano
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose [elemento] when(condici√≥n)
                   []         otherwise
    )
}

function pertenece_A_(elemento, lista) {
    /*
        PROP√ìSITO:
            * Indica si **elemento** pertenece a la lista dada.
        PAR√ÅMETROS:
            * elemento: Elemento
            * lista: [Elemento]
        TIPO: Booleano
        PRECONDICIONES:
            * El elemento dado debe ser del mismo tipo que los elementos de la lista dada.
    */
    elementosPorMirar := lista 

    while (not esVac√≠a(elementosPorMirar) && elemento /= primero(elementosPorMirar)) {
        elementosPorMirar := resto(elementosPorMirar)
    }

    return (not esVac√≠a(elementosPorMirar))
}