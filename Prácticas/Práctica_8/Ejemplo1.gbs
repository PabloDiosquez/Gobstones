// Escribir una funci칩n celdaActual que describa la representaci칩n de la celda actual como valor del tipo Celda.

type Celda is record {
    /*
        PROP칍SITO:
            * Modelar una celda del tablero.
        INVARIANTE DE REPRESENTACI칍N:
            * Los n칰meros son todos mayores o iguales a cero.
    */

    field cantidadDeAzules  // Un valor de tipo N칰mero.
    field cantidadDeNegras  // Un valor de tipo N칰mero.
    field cantidadDeRojas   // Un valor de tipo N칰mero.
    field cantidadDeVerdes  // Un valor de tipo N칰mero.
}

function celdaActual() {
    /*
        PROP칍SITO:
            * Describe la celda actual como un registro de tipo Celda.
        TIPO: Celda.
        PRECONDICIONES:
            * No tiene (es una funcipon total).
    */
    
    return (Celda(
        cantidadDeAzules <- nroBolitas(Azul),
        cantidadDeNegras <- nroBolitas(Negro),
        cantidadDeRojas  <- nroBolitas(Rojo),
        cantidadDeVerdes <- nroBolitas(Verde)
    ))
}

游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳游댳
type Carta is record {
    /*
        PROP칍SITO:
            * Modelar cartas espa침olas de Truco.
        INVARIANTE DE REPRESENTACI칍N:
            * El n칰mero est치 comprendido entre 1 y 7 o entre 10 y 12.
    */

    field palo // Un valor de tipo Palo
    field n칰mero // Un valor de tipo N칰mero.
}

function asDeEspadas() {
    /*
        PROP칍SITO:
            * Describe el as de espadas.
        TIPO: Carta
        PRECONDICIONES:
            * No tiene (es una funci칩n total).
    */
    
    return (Carta(palo <- Espadas, numero <- 1))
}

// Funciones observadoras 

function envidoSimpleCon_Y_(carta1, carta2) {
    /*
        PROP칍SITO:
            * Describe el valor del envido simple de las dos cartas dadas.
        PAR츼METROS:
            * carta1: Carta 
            * carta2: Carta
        TIPO: N칰mero.
        PRECONDICIONES:
            * Las cartas dadas deben ser del mismo palo y no deben ser figuras.
    */
    
    return (n칰mero(carta1) + n칰mero(carta2) + 20)
}

function la_Y_LaSonDelMismoPalo(carta1, carta2) {
    /*
        PROP칍SITO:
            * Indica si las cartas dadas son del mismo palo.
        PAR츼METROS:
            * carta1: Carta
            * carta2: Carta
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci칩n total).
    */
    
    return (palo(carta1) == palo(carta2))
}

//游댲 Variantes

type Palo is variant {
    /*
        PROP칍SITO:
            * Modela los distintos palos de las cartas espa침olas.
    */

    case Basto  {}
    case Espada {}
    case Oro    {}
    case Copa   {}
}

function anchoDe_(paloAUsar) {
    /*
        PROP칍SITO:
            * Describe el ancho de **paloAUsar**.
        PAR츼METROS:
            * palo: Palo
        TIPO: Carta
        PRECONDICIONES:
            * No tiene (es una funci칩n total).
    */
    
    return (Carta(palo <- paloAUsar, numero <- 1))
}

function c칩digoDelPalo_(palo) {
    /*
        PROP칍SITO:
            * Describe el c칩digo del palo dado.
        PAR츼METROS:
            * palo: Palo
        TIPO: N칰mero.
        PRECONDICIONES:
            * No tiene (es una funci칩n total).
    */
    
    return (choose 100 when (palo == Basto)
                   200 when (palo == Copa)
                   300 when (palo == Espada)
                   200 when (palo == Oro)
                   boom("Esto NO deber칤a pasar. 쮸lteraste los palos?") otherwise 
    )
}

function siguientePalo_(palo) {
    /*
        PROP칍SITO:
            * Describe el palo siguiente al dado.
        PAR츼METROS:
            * palo: Palo
        TIPO: Palo
        PRECONDICIONES:
            * No tiene (es una funci칩n total).
    */
    
    return (choose Copa   when (palo == Basto)
                   Espada when (palo == Copa)
                   Oro    when (palo == Espada)
                   Basto  when (palo == Oro)
                   boom("Esto NO deber칤a pasar. 쮸lteraste los palos?") otherwise
    )
}

procedure PonerLosAnchos() {
    /*
        PROP칍SITO:
            * Pone los cuatro anchos en el tablero.
        PRECONDICIONES:
            * Debe haber al menos tres celdas lindantes a la actual al Este.
        OBSERVACIONES:
            * Recorrido de transformaci칩n sobre los palos. 
    */
    
    paloActual := Basto

    while (paloActual != Oro) {
        PonerCarta(anchoDe_(paloActual))
        Mover(Este)
        paloActual := siguientePalo_(paloActual)
    }

    PonerCarta(anchoDe_(paloActual))
}