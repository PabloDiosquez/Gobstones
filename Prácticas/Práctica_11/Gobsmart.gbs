// Los directivos del supermercado GobsMart nos piden modelar el funcionamiento de las cajas
// de cobro en una sucursal. Para esto usaremos los siguientes tipos:

type TipoDePago is variant {
    /* PROP: 
        * Modelar Tipos de pago aceptados.
    */

    case Tarjeta {}
    case MartPago {}
    case Efectivo {}
}

type Producto is record{
    /* 
    PROP: 
        * Modelar productos.
    INV.REP.: 
        * precio > 0 
    */

    field nombre // String
    field marca // String
    field precio // N√∫mero
}

type Cliente is record {
    /* PROP: 
        * Modelar clientes.
    */

    field dni // String
    field tipoDePago // TipoDePago
    field productos // [Producto]
}

type Caja is record {
    /* 
    PROP: 
    * Modelar cajas.
    INV.REP.: 
    * n√∫mero > 0
    * facturado >= 0
    */

    field n√∫mero // N√∫mero
    field clientesEsperando // [Cliente]
    field aceptaPagos // [TipoDePago]
    field esR√°pida // Bool
    field facturado // N√∫mero
}

// 1. Armar ejemplos para visualizar el modelo y sus datos.


// 2. Implementar las siguientes funciones:
// a) cantidadDeClientesEsperandoEn_, que dada una caja, describe la
// cantidad de clientes que est√°n esperando en la misma.

function cantidadDeClientesEsperandoEn_(caja) {
    /*
        PROP√ìSITO:
            * Describe la cantidad de clientes que est√°n esperando en la caja dada.
        PAR√ÅMETROS:
            * caja: Caja
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * Recorrido de totalizaci√≥n sobre la lista de clientes de la caja dada, para contarlos.
    */
    
    // clientesVistosAlMomento := 0

    // foreach cliente in clientesEsperando(caja) {
    //     clientesVistosAlMomento := clientesVistosAlMomento + 1
    // }
    // return (clientesVistosAlMomento)

    return (longitudDe_(clientesEsperando(caja)))
}

// b) cajaMenosOcupadaDe_, que dada una lista de cajas describe la caja con
// menos clientes esperando entre todas las de esa lista.

function cajaMenosOcupadaDe_(cajas) {
    /*
        PROP√ìSITO:
            * Describe la caja con menos clientes esperando de la lista de cajas dadas.
        PAR√ÅMETROS:
            * cajas: [Caja]
        TIPO: Caja
        PRECONDICIONES:
            * La lista de cajas dada no debe ser vac√≠a.
        OBSERVACIONES:
            * Recorrido de m√≠nimos.
    */
    
    cajaConMenosClientesEsperandoAlMomento := primero(cajas)

    foreach caja in resto(cajas) {
        cajaConMenosClientesEsperandoAlMomento := cajaConMenosClientesEsperandoEntre_Y_(cajaConMenosClientesEsperandoAlMomento, caja)
    }
    return (cajaConMenosClientesEsperandoAlMomento)
}

function cajaConMenosClientesEsperandoEntre_Y_(caja1, caja2) {
    /*
        PROP√ìSITO:
            * Describe la caja con menos clientes esperando entre las dos cajas dadas.
        PAR√ÅMETROS:
            * caja1: Caja
            * caja2: Caja
        TIPO: Caja
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * Describe la segunda caja si tienen la misma cantidad de clientes.
    */
    
    return (choose caja1 when (cantidadDeClientesEsperandoEn_(caja1) < cantidadDeClientesEsperandoEn_(caja2))
                   caja2 otherwise 
    )
}

// c) gobsMart_conIngresoDe_aCaja_, que dada una lista de cajas, un cliente y
// un n√∫mero de caja, describe la misma lista de cajas pero actualizando la caja del
// n√∫mero dado para registrar que el cliente dado ingres√≥ en la misma. Tener en
// cuenta que el cliente se debe agregar al final de la cola de espera.
// d) gobsMart_conIngresosDe_, que dada una lista de cajas y una lista de
// clientes, describe una lista de cajas actualizada, donde cada cliente de la lista
// dada ingres√≥ a una caja que acepta el medio de pago que posee, y que est√©
// menos ocupada en el momento que ingresa.
// e) caja_conPrimeroFacturado, que dada una caja, describe la caja resultante
// de facturar al primero de los clientes de la caja dada (o sea, el cliente se retir√≥ y
// la caja actualiz√≥ sus datos). Se puede suponer que el cliente eligi√≥ bien la caja
// de acuerdo a su tipo de pago.
// f) gobsMart_conCliente_cambiaACaja_, que dada una lista de cajas, el DNI
// de un cliente y un n√∫mero de caja, describe la lista de cajas actualizada, donde
// el cliente con el DNI dado se cambi√≥ al n√∫mero de caja dado. Se puede suponer
// que existe un cliente con el DNI dado esperando en alguna de las cajas del
// gobsMart.
// g) fila_ConAumentoDePrecioAMarolio, que dada una lista de clientes,
// describe la lista de clientes dada donde se aumente en 10 pesos todos los
// productos de la marca ‚ÄúMarolio‚Äù que tengan en su poder.


// FUNCIONES AUXILIARES üê±‚ÄçüöÄ

function longitudDe_(lista) {
    /*
        PROP√ìSITO:
            * Describe la longitud de la lista dada.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: N√∫mero.
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    cantidadDeElementosAlMomento := 0
    foreach elemento in lista {
        cantidadDeElementosAlMomento := cantidadDeElementosAlMomento + 1
    }
    return (cantidadDeElementosAlMomento)
}