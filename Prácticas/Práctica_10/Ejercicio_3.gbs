// Construir la funci贸n aparicionesDeColor_, que dado un color, colorBuscado,
// describa una lista de n煤meros que indican para cada una de las celdas del tablero
// recorridas en direcci贸n principal Norte y direcci贸n secundaria Oeste, la cantidad de
// bolitas del color buscado en esa celda del tablero.

function aparicionesDeColor_(colorBuscado) {
    /*
        PROPSITO:
            * Describe una lista de n煤meros que indican, para cada una de las celdas del tablero, la cantidad de bolitas del color buscado que cada una tiene.
        PARMETROS:
            * colorBuscado: Color
        TIPO: [N煤mero]
        PRECONDICIONES:
            * No tiene (es una funci贸n total).
        OBSERVACIONES:
            * Recorrido de ...
    */

    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte, Oeste)

    bolitasDelColorBuscadoAlMomento := [nroBolitas(colorBuscado)]

    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Norte, Oeste)) {
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte, Oeste)    

        bolitasDelColorBuscadoAlMomento := bolitasDelColorBuscadoAlMomento ++ [nroBolitas(colorBuscado)]
    }

    return (bolitasDelColorBuscadoAlMomento)
}

// FUNCIONES AUXILARES 

procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROPSITO:
            * Ubica el cabezal en el inicio de un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PARMETROS:
            * dirPrincipal: Direcci贸n - La primera direcci贸n del recorrido.
            * dirSecundaria: Direcci贸n - La segunda direcci贸n del recorrido.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}

// b.
function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROPSITO:
            * Indica si existe una celda siguiente en un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PARMETROS:
            * dirPrincipal: Direcci贸n - La primera direcci贸n del recorrido.
            * dirSecundaria: Direcci贸n - La segunda direcci贸n del recorrido.
        TIPO: Booleano.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */  
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}

// c.
procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROPSITO:
            * Mueve el cabezal a la siguiente celda de un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PARMETROS:
            * dirPrincipal: Direcci贸n - Describe la primera direcci贸n del recorrido.
            * dirSecundaria: Direcci贸n - Describe la segunda direcci贸n del recorrido.
        PRECONDICIONES:
            * Debe existir al menos una celda siguiente en el recorrido.
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */
    if (puedeMover(dirPrincipal)){
        Mover(dirPrincipal)
    }
    else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}