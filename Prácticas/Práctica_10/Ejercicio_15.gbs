// Construir la funci√≥n sinDuplicados_, que dada una lista, describa una lista que tenga
// todos los elementos de la lista dada, pero donde no aparecen elementos repetidos,
// pues las repeticiones que aparecen luego de la primera fueron eliminadas.
// Por ejemplo, sinDuplicados_([1,3,4,2,4,3,5]) describe a la lista
// [1,3,4,2,5]. Observar que no es lo mismo describir a la lista [1,2,4,3,5], que
// podr√≠a ser un resultado v√°lido, pero no es el solicitado (porque no se conserv√≥ el
// primero de cada uno).

function sinDuplicados_(lista) {
    /*
        PROP√ìSITO:
            * Describe una lista que tiene todos los elementos de la lista dada, pero sin repetidos.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    elementosPorMirar := lista

    sinRepetidos := []

    while (not esVac√≠a(elementosPorMirar)) {
        
        sinRepetidos := sinRepetidos ++ singular_SiNoPerteneceA_(primero(elementosPorMirar), sinRepetidos)

        elementosPorMirar := resto(elementosPorMirar)
    }

    return (sinRepetidos)
}

// FUNCIONES AUXILIARES üê±‚Äçüèç

function singular_SiNoPerteneceA_(elemento, lista) {
    /*
        PROP√ìSITO:
            * Describe la lista formada √∫nicamente por **elemento** si √©ste no pertenece a la lista dada; en caso contrario, describe la lista vac√≠a.
        PAR√ÅMETROS:
            * elemento: Elemento
            * lista: [Elemento]
        TIPO: [Elemento]
        PRECONDICIONES:
            * El elemento dado debe tener el mismo tipo que los elementos de la lista dada.
    */
    
    return (singular_Si_Vac√≠oSino(elemento, not pertenece_A_(elemento, lista)))
}

function singular_Si_Vac√≠oSino(elemento, condici√≥n) {
    /*
        PROP√ìSITO:
            * Describe la lista formada √∫nicamente por **elemento** si la condici√≥n dada es verdadera; caso contrario, describe la lista vac√≠a.
        PAR√ÅMETROS:
            * elemento: Elemento
            * condici√≥n: Booleano
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose [elemento] when (condici√≥n)
                   []         otherwise
    )
}

function pertenece_A_(elemento, lista) {
    /*
        PROP√ìSITO:
            * Indica si el elemento dado pertenece a la lista dada.
        PAR√ÅMETROS:
            * elemento: Elemento
            * lista: [Elemento]
        TIPO: Booleano.
        PRECONDICIONES:
            * El elemento dado debe tener el mismo tipo que los elementos de la lista dada.
    */
    
    elementosPorMirar := lista


    while (not esVac√≠a(elementosPorMirar) && primero(elementosPorMirar) /= elemento) {
        elementosPorMirar := resto(elementosPorMirar)
    }

    return (not esVac√≠a(elementosPorMirar))
}