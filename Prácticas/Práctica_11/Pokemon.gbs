// Se desea modelar una parte de un juego de P√≥kemon mediante los siguientes tipos:

type TipoDeP√≥kemon is variant{
    /* 
    PROP√ìSITO:
        * Modelar los tipos de P√≥kemon posibles */
    case Tierra {}
    case Agua {}
    case Fuego {}
}

type P√≥kemon is record {
    /*
     PROP√ìSITO: 
        *Modelar un P√≥kemon
    INV.REP.: 
        * La fuerza y el nivel son mayores o iguales a 0
        * Si est√° debilitado, su fuerza es cero.
     */

    field tipo // TipoDeP√≥kemon
    field fuerza // N√∫mero
    field est√°Vivo // Booleano.
    field nivel // N√∫mero
}

// Ejercicios con Registros y Variantes
// Definir las siguientes funciones:
// a) _esM√°sFuerteQue_, que dados dos P√≥kemon indica si el primero tiene m√°s
// fuerza que el segundo.

function _esM√°sFuerteQue_(p√≥kemon1, p√≥kemon2) {
    /*
        PROP√ìSITO:
            * Indica si el primer p√≥kemon dado tiene m√°s fuerza que el segundo dado.
        PAR√ÅMETROS:
            * p√≥kemon1: P√≥kemon
            * p√≥kemon2: P√≥kemon
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (fuerza(p√≥kemon1) > fuerza(p√≥kemon2))
}

// b) esDeMayorNivel_Que_, que dados dos P√≥kemon indica si el si el primero
// tiene un nivel m√°s alto que el segundo.

function esDeMayorNivel_Que_(p√≥kemon1, p√≥kemon2) {
    /*
        PROP√ìSITO:
            * Indica si el primer p√≥kemon dado tiene un nivel m√°s alto que el segundo p√≥kemon dado.
        PAR√ÅMETROS:
            * p√≥kemon1: P√≥kemon
            * p√≥kemon2: P√≥kemon
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (nivel(p√≥kemon1) > nivel(p√≥kemon2))
}

// c) p√≥kemon_PotenciadoEn_, que dado un P√≥kemon y un n√∫mero, describe el
// P√≥kemon resultante de multiplicar la fuerza y el nivel del P√≥kemon dado por ese
// n√∫mero.

function p√≥kemon_PotenciadoEn_(p√≥kemon, n√∫mero) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon resultante de multiplicar la fuerza y el nivel del p√≥kemon dado por el n√∫mero dado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
            * n√∫mero: N√∫mero
        TIPO: P√≥kemon
        PRECONDICIONES:
            * **n√∫mero** debe ser >= 0.
    */
    
    return (
        Pok√©mon(p√≥kemon | 
                          fuerza <- fuerza(p√≥kemon)*n√∫mero
                        , nivel  <- nivel(p√≥kemon) *n√∫mero 
        )
    )
}

// d) p√≥kemon_ConValoresDuplicados, que dado un P√≥kemon, describe el
// P√≥kemon resultante de duplicar la fuerza y el nivel del Pok√©mon dado.

function p√≥kemon_ConValoresDuplicados(p√≥kemon) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon que resulta de duplicar los valores de fuerza y de nivel del p√≥kemon dado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
        TIPO: P√≥kemon
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (p√≥kemon_PotenciadoEn_(p√≥kemon, 2))
}

// e) p√≥kemon_PotenciadoSiEsDeTipo_En(pok√©mon , tipo,n), que dado un
// P√≥kemon, un tipo de P√≥kemon y un n√∫mero, describe el Pok√©mon resultante de
// potenciar el dado en el n√∫mero dado, solamente si es del tipo recibido, y el
// original si no.

function p√≥kemon_PotenciadoSiEsDeTipo_En_(p√≥kemon, tipo, n√∫mero) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon resultante de potenciar en el n√∫mero dado al p√≥kemon dado, s√≥lo si es del tipo recibido; en caso contrario, describe el p√≥kemon original.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
            * tipo: TipoDeP√≥kemon
            * n√∫mero: N√∫mero
        TIPO: P√≥kemon
        PRECONDICIONES:
            * **n√∫mero** debe ser >= 0.
    */
    
    return (choose p√≥kemon_PotenciadoEn_(p√≥kemon, n√∫mero) when (_esDeTipo_(pok√©mon, tipo))
                   p√≥kemon otherwise
    )
}

function _esDeTipo_(p√≥kemon, tipoDado) {
    /*
        PROP√ìSITO:
            * Indica si el p√≥kemon dado es del tipo dado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
            * tipoDado: TipoDeP√≥kemon
        TIPO: Booleano.
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (tipo(pok√©mon) == tipoDado)
}

// f) p√≥kemon_Derrotado, que dado un P√≥kemon, describe el Pok√©mon resultante
// de debilitar al P√≥kemon dado (o sea, su fuerza ser√° 0 y su estado, debilitado).

function p√≥kemon_Derrotado(p√≥kemon) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon que resulta de debilitar al p√≥kemon dado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
        TIPO: P√≥kemon
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * Si el p√≥kemon est√° debilitado, su fuerza es cero.
    */
    
    return (P√≥kemon(p√≥kemon | fuerza <- 0))
}


// Ejercicios con Listas de Registros
// Definir las siguientes funciones:
// a) p√≥kemonDe_Entrenados_, que dada una lista de P√≥kemon y un n√∫mero,
// describe la lista resultante de potenciar cada P√≥kemon de la lista dada en la
// cantidad dada.

function p√≥kemonDe_Entrenados_(p√≥kemons, n√∫mero) {
    /*
        PROP√ìSITO:
            * Describe la lista que resulta de potenciar en el n√∫mero dado los p√≥kemons de la lista dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
            * n√∫mero: N√∫mero
        TIPO: [P√≥kemon]
        PRECONDICIONES:
            * **n√∫mero** debe ser >= 0.
    */
    
    p√≥kemonsPotenciadosAlMomento := []

    foreach p√≥kemon in p√≥kemons {
        p√≥kemonsPotenciadosAlMomento := p√≥kemonsPotenciadosAlMomento ++
                                        [p√≥kemon_PotenciadoEn_(p√≥kemon, n√∫mero)]
    }

    return (p√≥kemonsPotenciadosAlMomento)
}

// b) p√≥kemonDe_DelTipo_, que dada una lista de P√≥kemon y un tipo de P√≥kemon,
// describe la lista de aquellos P√≥kemon de la lista dada que son del tipo dado.

function p√≥kemonDe_DelTipo_(p√≥kemons, tipoDado) {
    /*
        PROP√ìSITO:
            * Describe la lista de los p√≥kemons de la lista dada que son del tipo dado.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
            * tipoDado: TipoDeP√≥kemon
        TIPO: [P√≥kemon]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    p√≥kemonsDelTipoDadoAlMomento := []

    foreach p√≥kemon in p√≥kemons {
        p√≥kemonsDelTipoDadoAlMomento := p√≥kemonsDelTipoDadoAlMomento ++
                                        singular_Si_(p√≥kemon, _esDeTipo_(p√≥kemon, tipo))
    }

    return (p√≥kemonsDelTipoDadoAlMomento)
}

// c) elM√°sFuerteDe_, que dada una lista de P√≥kemon, describe el p√≥kemon de
// nivel m√°s alto de toda la lista; si hay dos o m√°s del mismo nivel m√°s alto, da lo
// mismo cual se describe. ¬øQu√© precondici√≥n se debe exigir?

function elM√°sFuerteDe_(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de nivel m√°s alto de la lista de p√≥kemons dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: P√≥kemon
        PRECONDICIONES:
            * La lista de p√≥kemons dada no debe ser vac√≠a.
    */
    
    elM√°sFuerteAlMomento := primero(p√≥kemons)

    foreach p√≥kemon in resto(p√≥kemons) {
        elM√°sFuerteAlMomento := elM√°sFuerteEntre_Y_(elM√°sFuerteAlMomento, p√≥kemon)
    }

    return (elM√°sFuerteAlMomento)
}

function elM√°sFuerteEntre_Y_(p√≥kemon1, p√≥kemon2) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de nivel m√°s alto entre los dos p√≥kemons dados.
        PAR√ÅMETROS:
            * p√≥kemon1: P√≥kemon
            * p√≥kemon2: P√≥kemon
        TIPO: P√≥kemon
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose p√≥kemon1 when(nivel(p√≥kemon1) > nivel(p√≥kemon2))
                   p√≥kemon2 otherwise
    )
}

// d) p√≥kemonDe_DelTipo_Duplicados, que dada una lista de P√≥kemons y un tipo
// de P√≥kemon, describe lista de P√≥kemon resultante de duplicar aquellos
// P√≥kemon de la lista original que son del tipo dado, dejando los dem√°s
// exactamente igual. El orden en la lista resultante debe ser el mismo que en la
// lista dada.

function p√≥kemonDe_DelTipo_Duplicados(p√≥kemons, tipo) {
    /*
        PROP√ìSITO:
            * Describe la lista de p√≥kemons que resulta de duplicar aquellos p√≥kemons de la lista dada que son del tipo dado, dejando los dem√°s exactamente igual.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
            * tipo: tipoDeP√≥kemon
        TIPO: [P√≥kemon]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    p√≥kemonsDelTipoDadoAlMomento := []

    foreach p√≥kemon in p√≥kemons {
        p√≥kemonsDelTipoDadoAlMomento := p√≥kemonsDelTipoDadoAlMomento ++ 
                                        singular_Si_(p√≥kemon, es_DelTipo_(p√≥kemon, tipo))
    }

    return (p√≥kemonsDe_Duplicados(p√≥kemonsDelTipoDadoAlMomento))
}

function p√≥kemonsDe_Duplicados(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe la lista que resulta de duplicar los valores de fuerza y nivel de cada p√≥kemon de la lista dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: [P√≥kemon]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    p√≥kemonsDuplicadosAlMomento := []

    foreach p√≥kemon in p√≥kemons {
        p√≥kemonsDuplicadosAlMomento := p√≥kemonsDuplicadosAlMomento ++ [p√≥kemon_ConValoresDuplicados(p√≥kemon)]
    }

    return (p√≥kemonsDebilitadosAlMomento)
}


// e) elP√≥kemonM√°sD√©bilDe_, que dada una lista de P√≥kemon describe al
// P√≥kemon de nivel m√°s bajo de toda la lista; si hay dos o m√°s del mismo nivel
// m√°s bajo, da lo mismo cual se describe. ¬øCu√°l es la precondici√≥n de esta
// funci√≥n?

function elP√≥kemonM√°sD√©bilDe_(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de nivel m√°s bajo de la lista de p√≥kemons dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: P√≥kemon
        PRECONDICIONES:
            * La lista de p√≥kemons dada debe ser no vac√≠a.
    */
    
    p√≥kemonM√°sD√©bilAlMomento := primero(p√≥kemons)

    foreach p√≥kemon in resto(p√≥kemons) {
        p√≥kemonM√°sD√©bilAlMomento := elM√°sD√©bilEntre_Y_(p√≥kemonM√°sD√©bilAlMomento, p√≥kemon)
    }

    return (p√≥kemonM√°sD√©bilAlMomento)
}

function elM√°sD√©bilEntre_Y_(p√≥kemon1, p√≥kemon2) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de nivel m√°s bajo de los dos p√≥kemons dados.
        PAR√ÅMETROS:
            * p√≥kemon1: P√≥kemon
            * p√≥kemon2: P√≥kemon
        TIPO: P√≥kemon
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose p√≥kemon1 when (nivel(p√≥kemon1) < nivel(p√≥kemon2))
                   p√≥kemon2 otherwise
    )
}

// f) p√≥kemonsDebilitadosDe_, que dada una lista de P√≥kemon, describe la lista
// de aquellos p√≥kemons de la lista dada que est√°n debilitados.

function p√≥kemonsDebilitadosDe_(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe la lista de p√≥kemons debilitados de la lista dada. 
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: [P√≥kemon]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */

    p√≥kemonsDebilitadosAlMomento := []

    foreach p√≥kemon in p√≥kemons {
        p√≥kemonsDebilitadosAlMomento := p√≥kemonsDebilitadosAlMomento ++ 
                                                singular_Si_(p√≥kemon, est√°Debilitado_(p√≥kemon))
    }
    
    return (p√≥kemonsDebilitadosAlMomento)
}

function est√°Debilitado_(p√≥kemon) {
    /*
        PROP√ìSITO:
            * Indica si el p√≥kemon dado est√° debilitado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (fuerza(p√≥kemon) == 0)
}

// g) cantidadDeP√≥kemonSaludablesEn_, que dada una lista de P√≥kemon,
// describe la cantidad de P√≥kemon de la lista que no est√°n debilitados.

function cantidadDeP√≥kemonSaludablesEn_(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe la cantidad de p√≥kemons saludables de la lista de p√≥kemons dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES: 
            * Recorrido de acumulaci√≥n sobre la lista de p√≥kemons dada.
    */
    
    cantidadDeP√≥kemonSaludablesAlMomento := 0

    foreach p√≥kemon in p√≥kemons {
        cantidadDeP√≥kemonSaludablesAlMomento := cantidadDeP√≥kemonSaludablesAlMomento + 
                                                            unoSi_CeroSino(est√°Saludable_(p√≥kemon))
    }

    return (cantidadDeP√≥kemonSaludablesAlMomento)
}

function est√°Saludable_(p√≥kemon) {
    /*
        PROP√ìSITO:
            * Indica si el p√≥kemon dado est√° saludable.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (fuerza(p√≥kemon) > 0)
}


// h) existeP√≥kemonEn_ConFuerza_Tipo_YNivel_, que dada una lista de
// P√≥kemon, un n√∫mero para indicar una fuerza, un tipo de P√≥kemon y un n√∫mero
// para indicar un nivel, indica si en la lista dada existe algun P√≥kemon de ese tipo
// con esa fuerza y ese nivel.

function existeP√≥kemonEn_ConFuerza_Tipo_YNivel_(p√≥kemons, fuerza, tipo, nivel) {
    /*
        PROP√ìSITO:
            * Indica si existe un p√≥kemon del tipo dado, con la fuerza dada y el nivel dado, en la lista de p√≥kemons dada. 
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
            * fuerza: N√∫mero
            * tipo: tipoDeP√≥kemon
            * nivel: N√∫mero
        TIPO: Booleano
        PRECONDICIONES:
            * **fuerza** debe ser >= 0.
            * **nivel**  debe ser >= 0.
        OBSERVACIONES:
            * Recorrido de b√∫squeda sobre la lista de p√≥kemons dada.
    */

    p√≥kemonsPorRecorrer := p√≥kemons 

    while (not esVac√≠a(p√≥kemonsPorRecorrer) && not _esDeTipo_ConFuerza_YNivel_(p√≥kemon, tipo, fuerza, nivel)) {
        p√≥kemonsPorRecorrer := resto(p√≥kemonsPorRecorrer)
    }
    
    return (not esVac√≠a(p√≥kemonsPorRecorrer))
}

function _esDeTipo_ConFuerza_YNivel_(p√≥kemon, tipoDado, fuerzaDada, nivelDado) {
    /*
        PROP√ìSITO:
            * Indica si el p√≥kemon dado es de tipo **tipoDado**, con fuerza **fuerzaDada** y nivel **nivelDado**.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
            * tipoDado: tipoDeP√≥kemon
            * fuerzaDada: N√∫mero
            * nivelDado: N√∫mero
        TIPO: Booleano
        PRECONDICIONES:
            * **fuerza** debe ser >= 0.
            * **nivel**  debe ser >= 0.
    */
    
    return (tipo(p√≥kemon) == tipoDado && fuerza(p√≥kemon) == fuerzaDada && nivel(p√≥kemon) == nivelDado)
}

// Ejercicio con Registros y Listas.
// Supongamos adem√°s que se definen el siguiente tipo:

type Entrenador is record{
    /* 
        PROP√ìSITO: 
            * Modelar un entrenador de P√≥kemon.
        INV.REP.: 
            * Identificador es un n√∫mero > 0 */

        field lista // [Pokemon]
        field identificador // N√∫mero
        field esT√°ctico // Booleano
}

// Definir las siguientes funciones, sin olvidar establecer adecuadamente las
// precondiciones:

// a) entrenador__, que dados un identificador y un booleano que indica si el
// entrenador es t√°ctico, describe un Entrenador con los datos dados. Notar que
// por defecto el entrenador no tiene P√≥kemon para entrenar.

function entrenador__(identificador, esT√°ctico) {
    /*
        PROP√ìSITO:
            * Describe un entrenador con los datos dados.
        PAR√ÅMETROS:
            * identificador: N√∫mero
            * esT√°ctico: Booleano
        TIPO: Entrenador
        PRECONDICIONES:
            * **identificador** es un n√∫mero > 0
    */
    
    return (
            Entrenador(
                        lista <- listaVac√≠a()
                    ,   identificador <- identificador
                    ,   esT√°ctico <- esT√°ctico
            )
    )
}


// b) entrenador_ConP√≥kemon_Agregado, que dados un entrenador y un
// P√≥kemon, describe al entrenador resultante de agregar al P√≥kemon dado a la
// lista de P√≥kemon del entrenador dado.

function entrenador_ConP√≥kemon_Agregado(entrenador, p√≥kemon) {
    /*
        PROP√ìSITO:
            * Describe al entrenador dado con su lista de p√≥kemons actualizada por el agregado del p√≥kemon dado.
        PAR√ÅMETROS:
            * entrenador: Entrenador
            * p√≥kemon: P√≥kemon
        TIPO: Entrenador
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (Entrenador(entrenador | lista <- lista(entrenador) ++ [p√≥kemon]))
}

// c) cantidadDeP√≥kemonDe_, que dado un entrenador, describe la cantidad de
// P√≥kemon del entrenador recibido.


function cantidadDeP√≥kemonDe_(entrenador) {
    /*
        PROP√ìSITO:
            * Describe la cantidad de p√≥kemons del entrenador dado.
        PAR√ÅMETROS:
            * entrenador: Entrenador
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (cantidadDeElementosDe_(lista(entrenador)))
}

// d) cantidadTotalDeP√≥kemonEn_, que dada una lista de entrenadores, describe
// la cantidad total de P√≥kemon entre todos los entrenadores de la lista.

function cantidadTotalDeP√≥kemonEn_(entrenadores) {
    /*
        PROP√ìSITO:
            * Describe la cantidad total de p√≥kemons entre todos los entrenadores de la lista dada.
        PAR√ÅMETROS:
            * entrenadores: [Entrenador]
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    cantidadDeP√≥kemonsAlMomento := 0

    foreach entrenador in entrenadores {
        cantidadDeP√≥kemonsAlMomento := cantidadDeP√≥kemonsAlMomento ++ cantidadDeP√≥kemonDe_(entrenador)
    }

    return (cantidadDeP√≥kemonsAlMomento)
}

// e) entrenadorM√°sAntiguoEntre_Y_, que dados dos entrenadores, describe al
// entrenador m√°s antiguo de ambos (o sea, el que tiene menor n√∫mero de
// identificaci√≥n).

function entrenadorM√°sAntiguoEntre_Y_(primerEntrenador, segundoEntrenador) {
    /*
        PROP√ìSITO:
            * Describe al entrenador m√°s antiguo entre los dos entrenadores dados.
        PAR√ÅMETROS:
            * primerEntrenador:  Entrenador
            * segundoEntrenador: Entrenador
        TIPO: Entrenador
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * El entrenador m√°s antiguo es el que tiene el menor n√∫mero de identificaci√≥n.
    */
    
    return (choose primerEntrenador  when (identificaci√≥n(primerEntrenador) < identificaci√≥n(segundoEntrenador))
                   segundoEntrenador otherwise
    )
}

// f) elM√°sAntiguoEn_, que dada una lista de entrenadores, describe al entrenador
// m√°s antiguo de la lista dada.

function elM√°sAntiguoEn_(entrenadores) {
    /*
        PROP√ìSITO:
            * Describe al entrenador m√°s antiguo de la lista de entrenadores dada.
        PAR√ÅMETROS:
            * entrenadores: [Entrenador]
        TIPO: Entrenador
        PRECONDICIONES:
            * La lista de entrenadores dada no debe ser vac√≠a.
        OBSERVACIONES:
            * Recorrido de b√∫squeda de un m√≠nimo sobre la lista de entrenadores.
    */
    
    entrenadorM√°sAntiguoVisto := primero(entrenadores)

    foreach entrenador in entrenadores {
        entrenadorM√°sAntiguoVisto := entrenadorM√°sAntiguoEntre_Y_(entrenadorM√°sAntiguoVisto, entrenador)
    }

    return (entrenadorM√°sAntiguoVisto)
}


// g) entrenadorGanadorDeDesaf√≠oEntre_Y_, que dados dos entrenadores,
// describe al Entrenador ganador del desaf√≠o.
// El desaf√≠o consiste en que compitan un P√≥kemon de cada entrenador hasta que
// se acaben los P√≥kemon de uno de ellos, resultando en batallas del primero con
// el primero, el segundo con el segundo, etc. En cada pelea entre dos P√≥kemon
// siempre gana el m√°s fuerte, y si tienen igual fuerza, la pelea no cuenta para
// ninguno de los dos. Gana el desaf√≠o el entrenador que consiga ganar m√°s
// batallas, o de haber empate en la cantidad de peleas ganadas, el de mayor
// antig√ºedad.

function entrenadorGanadorDeDesaf√≠oEntre_Y_(primerEntrenador, segundoEntrenador) {
    /*
        PROP√ìSITO:
            * Describe al entrenador ganador del desaf√≠o entre los dos entrenadores dados.
        PAR√ÅMETROS:
            * primerEntrenador:  Entrenador
            * segundoEntrenador: Entrenador
        TIPO: Entrenador
        PRECONDICIONES:
            * La lista de p√≥kemons de los entrenadores dados no debe ser vac√≠a.
    */
    
    cantidadDePeleasP√≥kemonGanadasPorElPrimerEntrenador  := cantidadDePeleasP√≥kemonGanadasPor_Contra_(lista(primerEntrenador), lista(segundoEntrenador))
    
    cantidadDePeleasP√≥kemonGanadasPorElSegundoEntrenador := cantidadDePeleasP√≥kemonGanadasPor_Contra_(lista(segundoEntrenador), lista(primerEntrenador))

    return (
             choose primerEntrenador when (cantidadDePeleasP√≥kemonGanadasPorElPrimerEntrenador > cantidadDePeleasP√≥kemonGanadasPorElSegundoEntrenador)
             segundoEntrenador       when (cantidadDePeleasP√≥kemonGanadasPorElSegundoEntrenador > cantidadDePeleasP√≥kemonGanadasPorElPrimerEntrenador)
             entrenadorM√°sAntiguoEntre_Y_(primerEntrenador, segundoEntrenador) otherwise 
    )
}

function cantidadDePeleasP√≥kemonGanadasPor_Contra_(p√≥kemons1, p√≥kemons2) {
    /*
        PROP√ìSITO:
            * Describe la cantidad de combates ganados por la primer lista de p√≥kemons dada vs. la segunda lista de p√≥kemons dada. 
        PAR√ÅMETROS:
            * p√≥kemons1: [P√≥kemon]
            * p√≥kemons2: [P√≥kemon]
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * Pelean un p√≥kemon de cada lista hasta que se acaben los P√≥kemon de una de ellos, resultando en batallas del primero con el primero, el segundo con el segundo, etc.
            * En cada pelea entre dos P√≥kemon siempre gana el m√°s fuerte, y si tienen igual fuerza, la pelea no cuenta para ninguno de los dos.
    */

    p√≥kemonsDeLaPrimerListaPorRecorrer  := p√≥kemons1
    p√≥kemonsDeLaSegundaListaPorRecorrer := p√≥kemons2

    cantidadDePeleasGanadasPorLaPrimerListaAlMomento := 0

    while (not esVac√≠a(p√≥kemonsDeLaPrimerListaPorRecorrer) && not esVac√≠a(p√≥kemonsDeLaSegundaListaPorRecorrer)) {
        
        cantidadDePeleasGanadasPorLaPrimerListaAlMomento := cantidadDePeleasGanadasPorLaPrimerListaAlMomento ++
        unoSi_CeroSino(es_M√°sFuerteQue_(primero(p√≥kemonsDeLaPrimerListaPorRecorrer), primero(p√≥kemonsDeLaSegundaListaPorRecorrer)))

        p√≥kemonsDeLaPrimerListaPorRecorrer  := resto(p√≥kemonsDeLaPrimerListaPorRecorrer)
        p√≥kemonsDeLaSegundaListaPorRecorrer := resto(p√≥kemonsDeLaSegundaListaPorRecorrer)
    }
    
    return (cantidadDePeleasGanadasPorLaPrimerListaAlMomento)
}


// h) entrenadorGanadorDeDesafioEn_, que dada una lista de entrenadores,
// describe al entrenador ganador del desaf√≠o entre todos los entrenadores.
// El desaf√≠o de cada par de entrenadores es id√©ntico al que se describi√≥ en el
// punto anterior. En primer lugar compiten el primer entrenador con el segundo, y
// luego de cada pelea el entrenador que gana compite con el siguiente de la lista,
// hasta que no haya m√°s entrenadores para competir. El ganador del desaf√≠o es el
// entrenador que gana la √∫ltima batalla.

function entrenadorGanadorDeDesafioEn_(entrenadores) {
    /*
        PROP√ìSITO:
            * Describe al entrenador ganador del desaf√≠o entre todos los entrenadores de la lista dada.
        PAR√ÅMETROS:
            * entrenadores: [Entrenador]
        TIPO: Entrenador
        PRECONDICIONES:
            * La lista de entrenadores dada no debe ser vac√≠a.
    */
    
    entrenadorGanadorAlMomento := primero(entrenadores)

    foreach entrenador in resto(entrenadores) {
        entrenadorGanadorAlMomento := entrenadorGanadorDeDesaf√≠oEntre_Y_(entrenadorGanadorAlMomento, entrenador)
    }

    return (entrenadorGanadorAlMomento)
}

// i) fuerzaTotalDe_, que dado un entrenador, describe el n√∫mero que es la suma
// de la fuerza de todos los P√≥kemon de ese entrenador.

function fuerzaTotalDe_(entrenador) {
    /*
        PROP√ìSITO:
            * Describe la suma de la fuerza de todos los p√≥kemons del entrenador dado.
        PAR√ÅMETROS:
            * entrenador: Entrenador
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    fuerzaTotalAlMomento := 0

    foreach p√≥kemon in lista(entrenador) {
        fuerzaTotalAlMomento := fuerzaTotalAlMomento + fuerza(p√≥kemon)
    }

    return (fuerzaTotalAlMomento)
}

// j) fuerzaTotalEnBatallaEn_, que dada una lista de entrenadores, describe el
// n√∫mero que es la suma de la fuerza de todos los P√≥kemon de todos los
// entrenadores recibidos.

function fuerzaTotalEnBatallaEn_(entrenadores) {
    /*
        PROP√ìSITO:
            * Describe la suma de la fuerza de todos los p√≥kemons de los entrenadores de la lista dada.
        PAR√ÅMETROS:
            * entrenadores: [Entrenador]
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    fuerzaTotalDeLosP√≥kemonsAlMomento := 0

    foreach entrenador in entrenadores {
        fuerzaTotalDeLosP√≥kemonsAlMomento := fuerzaTotalDeLosP√≥kemonsAlMomento + fuerzaTotalDe_(entrenador)
    }

    return (fuerzaTotalDeLosP√≥kemonsAlMomento)
}

// k) mejorP√≥kemonDe_ParaJugada, que dado un entrenador, si el entrenador es
// T√°ctico describe a su Pok√©mon de mayor nivel con sus valores duplicados, y si
// no es t√°ctico describe al primero de su lista de P√≥kemon.

function mejorP√≥kemonDe_ParaJugada(entrenador) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de mayor nivel del entrenador dado con sus valores duplicados, si √©ste es t√°ctico; en caso contrario, describe el primero de su lista de p√≥kemons.
        PAR√ÅMETROS:
            * entrenador: Entrenador
        TIPO: P√≥kemon
        PRECONDICIONES:
            * La lista de p√≥kemons del entrenador dado no debe ser vac√≠a.
    */
    
    return (choose p√≥kemon_ConValoresDuplicados(p√≥kemonDeMayorDeNivelDe_(entrenador)) when (esT√°ctico(entrenador))
                   primero(lista(entrenador)) otherwise
        )
}

function p√≥kemonDeMayorDeNivelDe_(entrenador) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de mayor nivel del entrenador dado.
        PAR√ÅMETROS:
            * entrenador: Entrenador
        TIPO: P√≥kemon
        PRECONDICIONES:
            * La lista de p√≥kemons del entrenador dado no debe ser vac√≠a.
    */
    
    return (p√≥kemonDeMayorNivelDe_(lista(entrenador)))
}

function p√≥kemonDeMayorDeNivelDe_(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de mayor nivel de la lista de p√≥kemons dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: P√≥kemon
        PRECONDICIONES:
            * La lista de p√≥kemons dada no debe ser vac√≠a.
    */
    
    p√≥kemonDeMayorNivelVisto := primero(p√≥kemons)

    foreach p√≥kemon in resto(p√≥kemons) {
        p√≥kemonDeMayorNivelVisto := p√≥kemonDeMayorNivelEntre_Y_(p√≥kemonDeMayorNivelVisto, p√≥kemon)
    }

    return (p√≥kemonDeMayorNivelVisto)
}

function p√≥kemonDeMayorNivelEntre_Y_(primerP√≥kemon, segundoP√≥kemon) {
    /*
        PROP√ìSITO:
            * 
        PAR√ÅMETROS:
            * primerP√≥kemon:  P√≥kemon
            * segundoP√≥kemon: P√≥kemon
        TIPO: P√≥kemon
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose primerP√≥kemon when (nivel(primerP√≥kemon) > nivel(segundoP√≥kemon))
                   segundoP√≥kemon otherwise
        )
}

// l) ganadorDeDesaf√≠oInteligenteDe_CombatesEntre_Y_, que dados un
// n√∫mero de combates y dos entrenadores, describe al entrenador ganador del
// desaf√≠o inteligente entre ambos.
// A diferencia del desaf√≠o com√∫n, un desaf√≠o inteligente consiste solamente en la
// cantidad de combates dada. En cada combate el entrenador usa su mejor
// P√≥kemon para esa jugada, que luego no vuelve a competir. Notar que no juegan
// todos los P√≥kemon de la lista como en el desaf√≠o com√∫n, sino solamente la
// cantidad dada. Nuevamente, gana el que m√°s combates gana, y si hay empate,
// el de mayor antig√ºedad.
// m) ganadorDeDesaf√≠oInteligenteDe_CombatesEn_, que dados un n√∫mero
// de combates por desaf√≠o y una lista de entrenadores, describe al entrenador
// ganador del desaf√≠o inteligente entre todos los entrenadores dados.
// El desaf√≠o inteligente entre varios entrenadores sigue la misma mec√°nica que el
// com√∫n, pero en el desaf√≠o entre cada par de entrenadores, se realiza un desaf√≠o
// inteligente.

// FUNCIONES AUXILIARES üê±‚Äçüèç

function unoSi_CeroSino(condici√≥n) {
    /*
        PROP√ìSITO:
            * Describe 1 si se cumple la condici√≥n dada; describe 0 en caso contrario.
        PAR√ÅMETROS:
            * condici√≥n: Booleano
        TIPO: N√∫mero (0 o 1)
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose 1 when (condici√≥n)
                   0 otherwise
    )
}

function listaVac√≠a() {
    /*
        PROP√ìSITO:
            * Describe la lista vac√≠a.
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return ([])
}

function cantidadDeElementosDe_(lista) {
    /*
        PROP√ìSITO:
            * Describe la cantidad de elementos de la lista dada.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * Recorrido de acumulaci√≥n de la cantidad de elementos de la lista dada.
    */
    
    cantidadDeElementosAlMomento := 0

    foreach elemento in lista {
        cantidadDeElementosAlMomento := cantidadDeElementosAlMomento + 1
    }

    return (cantidadDeElementosAlMomento)
}
