// Construir la funci√≥n sinLaPrimeraAparici√≥nDe_en_ que dado un elemento y una
// lista, describe la lista que se obtiene de eliminar una √∫nica vez el elemento, si es que
// este aparece en la lista.
// Por ejemplo, sinLaPrimeraAparici√≥nDe_en_(8,[4,8,42,15,8,42]) describe
// [4,42,15,8,42] y sinLaPrimerAparici√≥nDe_en_(42,[4,8,42,15,8,42])
// describe [4,8,15,8,42].

function sinLaPrimeraAparici√≥nDe_en_(elementoBuscado, lista) {
    /*
        PROP√ìSITO:
            * Describe la lista que se obtiene de eliminar una √∫nica vez el elemento dado de la lista dada, si es que √©ste aparece en la misma.
        PAR√ÅMETROS:
            * elemento: Elemento
            * lista: [Elemento]
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */

    return (subListaDe_Hasta_(lista, posici√≥nDe_enLaQueAparece_(lista, elementoBuscado)) ++
            subListaDe_Desde_(lista, posici√≥nDe_enLaQueAparece_(lista, elementoBuscado))
    )

}

// FUNCIONES AUXILIARES üê±‚Äçüèç

function subListaDe_Hasta_(lista, posici√≥n) {
    /*
        PROP√ìSITO:
            * Describe la sublista formada por todos los elementos de la lista dada desde el primero hasta la posici√≥n **posici√≥n**.
        PAR√ÅMETROS:
            * lista: [Elemento]
            * posici√≥n: N√∫mero
        TIPO: [Elemento]
        PRECONDICIONES:
            * **posici√≥n** debe ser >= 0.
    */
    
    elementosPorRecorrer := lista

    posici√≥nActual := 0

    listaDeElementosHasta := [] 

    while(not esVac√≠a(elementosPorRecorrer) && posici√≥nActual < posici√≥n){
        listaDeElementosHasta := listaDeElementosHasta ++ [primero(elementosPorRecorrer)]

        elementosPorRecorrer := resto(elementosPorRecorrer)

        posici√≥nActual := posici√≥nActual + 1
    }

    return (listaDeElementosHasta)
}

function subListaDe_Desde_(lista, posici√≥n) {
    /*
        PROP√ìSITO:
            * Describe la sublista formada por todos los elementos de la lista dada desde la posici√≥n **posici√≥n**.
        PAR√ÅMETROS:
            * lista: [Elemento]
            * posici√≥n: N√∫mero
        TIPO: [Elemento]
        PRECONDICIONES:
            * **posici√≥n** debe ser >= 0.
    */
    
    elementosPorRecorrer := lista

    posici√≥nActual := 0

    listaDeElementosDesde :=[]

    while (not esVac√≠a(elementosPorRecorrer)) {
        listaDeElementosDesde := listaDeElementosDesde ++ singular_Si_(primero(elementosPorRecorrer), posici√≥nActual > posici√≥n)

        elementosPorRecorrer := resto(elementosPorRecorrer)

        posici√≥nActual := posici√≥nActual + 1
    }

    return (listaDeElementosDesde)
}

function posici√≥nDe_enLaQueAparece_(lista, elemento) {
    /*
        PROP√ìSITO:
            * Describe la posici√≥n en la que aparece por primera vez, el elemento dado en la lista dada. 
        PAR√ÅMETROS:
            * elemento: Elemento
            * lista: [Elemento]
        TIPO: N√∫mero
        PRECONDICIONES:
            * La lista dada no debe ser vac√≠a.
            * El elemento dado debe aparecer al menos una vez en la lista.
    */

    elementosPorRecorrer := lista

    posici√≥nAlMomento := 0
    
    while (not esVac√≠a(elementosPorRecorrer) && primero(elementosPorRecorrer) /= elemento) {
        posici√≥nAlMomento := posici√≥nAlMomento + 1

        elementosPorRecorrer := resto(elementosPorRecorrer)
    }

    return (posici√≥nAlMomento)
}

function singular_Si_(elemento, condici√≥n) {
    /*
        PROP√ìSITO: 
            * Describe la lista formada √∫nicamente por el elemento dado si se cumple la condici√≥n dada; en caso contrario, describe la lista vac√≠a.
        PAR√ÅMETROS:
            * elemento: Elemento
            * condici√≥n: Booleano
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose [elemento] when (condici√≥n) 
                    []    otherwise)
}