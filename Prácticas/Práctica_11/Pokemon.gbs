// Se desea modelar una parte de un juego de P√≥kemon mediante los siguientes tipos:

type TipoDeP√≥kemon is variant{
    /* 
    PROP√ìSITO:
        * Modelar los tipos de P√≥kemon posibles */
    case Tierra {}
    case Agua {}
    case Fuego {}
}

type P√≥kemon is record {
    /*
     PROP√ìSITO: 
        *Modelar un P√≥kemon
    INV.REP.: 
        * La fuerza y el nivel son mayores o iguales a 0
        * Si est√° debilitado, su fuerza es cero.
     */

    field tipo // TipoDeP√≥kemon
    field fuerza // N√∫mero
    field est√°Vivo // Booleano.
    field nivel // N√∫mero
}

// Ejercicios con Registros y Variantes
// Definir las siguientes funciones:
// a) _esM√°sFuerteQue_, que dados dos P√≥kemon indica si el primero tiene m√°s
// fuerza que el segundo.

function _esM√°sFuerteQue_(p√≥kemon1, p√≥kemon2) {
    /*
        PROP√ìSITO:
            * Indica si el primer p√≥kemon dado tiene m√°s fuerza que el segundo dado.
        PAR√ÅMETROS:
            * p√≥kemon1: P√≥kemon
            * p√≥kemon2: P√≥kemon
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (fuerza(p√≥kemon1) > fuerza(p√≥kemon2))
}

// b) esDeMayorNivel_Que_, que dados dos P√≥kemon indica si el si el primero
// tiene un nivel m√°s alto que el segundo.

function esDeMayorNivel_Que_(p√≥kemon1, p√≥kemon2) {
    /*
        PROP√ìSITO:
            * Indica si el primer p√≥kemon dado tiene un nivel m√°s alto que el segundo p√≥kemon dado.
        PAR√ÅMETROS:
            * p√≥kemon1: P√≥kemon
            * p√≥kemon2: P√≥kemon
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (nivel(p√≥kemon1) > nivel(p√≥kemon2))
}

// c) p√≥kemon_PotenciadoEn_, que dado un P√≥kemon y un n√∫mero, describe el
// P√≥kemon resultante de multiplicar la fuerza y el nivel del P√≥kemon dado por ese
// n√∫mero.

function p√≥kemon_PotenciadoEn_(p√≥kemon, n√∫mero) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon resultante de multiplicar la fuerza y el nivel del p√≥kemon dado por el n√∫mero dado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
            * n√∫mero: N√∫mero
        TIPO: P√≥kemon
        PRECONDICIONES:
            * **n√∫mero** debe ser >= 0.
    */
    
    return (
        Pok√©mon(p√≥kemon | 
                          fuerza <- fuerza(p√≥kemon)*n√∫mero
                        , nivel  <- nivel(p√≥kemon) *n√∫mero 
        )
    )
}

// d) p√≥kemon_ConValoresDuplicados, que dado un P√≥kemon, describe el
// P√≥kemon resultante de duplicar la fuerza y el nivel del Pok√©mon dado.

function p√≥kemon_ConValoresDuplicados(p√≥kemon) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon que resulta de duplicar los valores de fuerza y de nivel del p√≥kemon dado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
        TIPO: P√≥kemon
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (p√≥kemon_PotenciadoEn_(p√≥kemon, 2))
}

// e) p√≥kemon_PotenciadoSiEsDeTipo_En(pok√©mon , tipo,n), que dado un
// P√≥kemon, un tipo de P√≥kemon y un n√∫mero, describe el Pok√©mon resultante de
// potenciar el dado en el n√∫mero dado, solamente si es del tipo recibido, y el
// original si no.

function p√≥kemon_PotenciadoSiEsDeTipo_En_(p√≥kemon, tipo, n√∫mero) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon resultante de potenciar en el n√∫mero dado al p√≥kemon dado, s√≥lo si es del tipo recibido; en caso contrario, describe el p√≥kemon original.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
            * tipo: TipoDeP√≥kemon
            * n√∫mero: N√∫mero
        TIPO: P√≥kemon
        PRECONDICIONES:
            * **n√∫mero** debe ser >= 0.
    */
    
    return (choose p√≥kemon_PotenciadoEn_(p√≥kemon, n√∫mero) when (_esDeTipo_(pok√©mon, tipo))
                   p√≥kemon otherwise
    )
}

function _esDeTipo_(p√≥kemon, tipoDado) {
    /*
        PROP√ìSITO:
            * Indica si el p√≥kemon dado es del tipo dado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
            * tipoDado: TipoDeP√≥kemon
        TIPO: Booleano.
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (tipo(pok√©mon) == tipoDado)
}

// f) p√≥kemon_Derrotado, que dado un P√≥kemon, describe el Pok√©mon resultante
// de debilitar al P√≥kemon dado (o sea, su fuerza ser√° 0 y su estado, debilitado).

function p√≥kemon_Derrotado(p√≥kemon) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon que resulta de debilitar al p√≥kemon dado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
        TIPO: P√≥kemon
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * Si el p√≥kemon est√° debilitado, su fuerza es cero.
    */
    
    return (P√≥kemon(p√≥kemon | fuerza <- 0))
}


// Ejercicios con Listas de Registros
// Definir las siguientes funciones:
// a) p√≥kemonDe_Entrenados_, que dada una lista de P√≥kemon y un n√∫mero,
// describe la lista resultante de potenciar cada P√≥kemon de la lista dada en la
// cantidad dada.

function p√≥kemonDe_Entrenados_(p√≥kemons, n√∫mero) {
    /*
        PROP√ìSITO:
            * Describe la lista que resulta de potenciar en el n√∫mero dado los p√≥kemons de la lista dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
            * n√∫mero: N√∫mero
        TIPO: [P√≥kemon]
        PRECONDICIONES:
            * **n√∫mero** debe ser >= 0.
    */
    
    p√≥kemonsPotenciadosAlMomento := []

    foreach p√≥kemon in p√≥kemons {
        p√≥kemonsPotenciadosAlMomento := p√≥kemonsPotenciadosAlMomento
                                             ++ [p√≥kemon_PotenciadoEn_(p√≥kemon, n√∫mero)]
    }

    return (p√≥kemonsPotenciadosAlMomento)
}

// b) p√≥kemonDe_DelTipo_, que dada una lista de P√≥kemon y un tipo de P√≥kemon,
// describe la lista de aquellos P√≥kemon de la lista dada que son del tipo dado.

function p√≥kemonDe_DelTipo_(p√≥kemons, tipoDado) {
    /*
        PROP√ìSITO:
            * Describe la lista de los p√≥kemons de la lista dada que son del tipo dado.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
            * tipoDado: TipoDeP√≥kemon
        TIPO: [P√≥kemon]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    p√≥kemonsDelTipoDadoAlMomento := []

    foreach p√≥kemon in p√≥kemons {
        p√≥kemonsDelTipoDadoAlMomento := p√≥kemonsDelTipoDadoAlMomento ++
                                                singular_Si_(p√≥kemon, _esDeTipo_(p√≥kemon, tipo))
    }

    return (p√≥kemonsDelTipoDadoAlMomento)
}

// c) elM√°sFuerteDe_, que dada una lista de P√≥kemon, describe el p√≥kemon de
// nivel m√°s alto de toda la lista; si hay dos o m√°s del mismo nivel m√°s alto, da lo
// mismo cual se describe. ¬øQu√© precondici√≥n se debe exigir?

function elM√°sFuerteDe_(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de nivel m√°s alto de la lista de p√≥kemons dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: P√≥kemon
        PRECONDICIONES:
            * La lista de p√≥kemons dada no debe ser vac√≠a.
    */
    
    elM√°sFuerteAlMomento := primero(p√≥kemons)

    foreach p√≥kemon in resto(p√≥kemons) {
        elM√°sFuerteAlMomento := elM√°sFuerteEntre_Y_(elM√°sFuerteAlMomento, p√≥kemon)
    }

    return (elM√°sFuerteAlMomento)
}

function elM√°sFuerteEntre_Y_(p√≥kemon1, p√≥kemon2) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de nivel m√°s alto entre los dos p√≥kemons dados.
        PAR√ÅMETROS:
            * p√≥kemon1: P√≥kemon
            * p√≥kemon2: P√≥kemon
        TIPO: P√≥kemon
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose p√≥kemon1 when(nivel(p√≥kemon1) > nivel(p√≥kemon2))
                   p√≥kemon2 otherwise
    )
}

// d) p√≥kemonDe_DelTipo_Duplicados, que dada una lista de P√≥kemons y un tipo
// de P√≥kemon, describe lista de P√≥kemon resultante de duplicar aquellos
// P√≥kemon de la lista original que son del tipo dado, dejando los dem√°s
// exactamente igual. El orden en la lista resultante debe ser el mismo que en la
// lista dada.




// e) elP√≥kemonM√°sD√©bilDe_, que dada una lista de P√≥kemon describe al
// P√≥kemon de nivel m√°s bajo de toda la lista; si hay dos o m√°s del mismo nivel
// m√°s bajo, da lo mismo cual se describe. ¬øCu√°l es la precondici√≥n de esta
// funci√≥n?

function elP√≥kemonM√°sD√©bilDe_(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de nivel m√°s bajo de la lista de p√≥kemons dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: P√≥kemon
        PRECONDICIONES:
            * La lista de p√≥kemons dada debe ser no vac√≠a.
    */
    
    p√≥kemonM√°sD√©bilAlMomento := primero(p√≥kemons)

    foreach p√≥kemon in resto(p√≥kemons) {
        p√≥kemonM√°sD√©bilAlMomento := elM√°sD√©bilEntre_Y_(p√≥kemonM√°sD√©bilAlMomento, p√≥kemon)
    }

    return (p√≥kemonM√°sD√©bilAlMomento)
}

function elM√°sD√©bilEntre_Y_(p√≥kemon1, p√≥kemon2) {
    /*
        PROP√ìSITO:
            * Describe el p√≥kemon de nivel m√°s bajo de los dos p√≥kemons dados.
        PAR√ÅMETROS:
            * p√≥kemon1: P√≥kemon
            * p√≥kemon2: P√≥kemon
        TIPO: P√≥kemon
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose p√≥kemon1 when (nivel(p√≥kemon1) < nivel(p√≥kemon2))
                   p√≥kemon2 otherwise
    )
}

// f) p√≥kemonsDebilitadosDe_, que dada una lista de P√≥kemon, describe la lista
// de aquellos p√≥kemons de la lista dada que est√°n debilitados.

function p√≥kemonsDebilitadosDe_(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe la lista de p√≥kemons debilitados de la lista dada. 
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: [P√≥kemon]
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */

    p√≥kemonsDebilitadosAlMomento := []

    foreach p√≥kemon in p√≥kemons {
        p√≥kemonsDebilitadosAlMomento := p√≥kemonsDebilitadosAlMomento ++ 
                                                singular_Si_(p√≥kemon, est√°Debilitado_(p√≥kemon))
    }
    
    return (p√≥kemonsDebilitadosAlMomento)
}

function est√°Debilitado_(p√≥kemon) {
    /*
        PROP√ìSITO:
            * Indica si el p√≥kemon dado est√° debilitado.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (fuerza(p√≥kemon) == 0)
}

// g) cantidadDeP√≥kemonSaludablesEn_, que dada una lista de P√≥kemon,
// describe la cantidad de P√≥kemon de la lista que no est√°n debilitados.

function cantidadDeP√≥kemonSaludablesEn_(p√≥kemons) {
    /*
        PROP√ìSITO:
            * Describe la cantidad de p√≥kemons saludables de la lista de p√≥kemons dada.
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES: 
            * Recorrido de acumulaci√≥n sobre la lista de p√≥kemons dada.
    */
    
    cantidadDeP√≥kemonSaludablesAlMomento := 0

    foreach p√≥kemon in p√≥kemons {
        cantidadDeP√≥kemonSaludablesAlMomento := cantidadDeP√≥kemonSaludablesAlMomento + 
                                                            unoSi_CeroSino(est√°Saludable_(p√≥kemon))
    }

    return (cantidadDeP√≥kemonSaludablesAlMomento)
}

function est√°Saludable_(p√≥kemon) {
    /*
        PROP√ìSITO:
            * Indica si el p√≥kemon dado est√° saludable.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (fuerza(p√≥kemon) > 0)
}


// h) existeP√≥kemonEn_ConFuerza_Tipo_YNivel_, que dada una lista de
// P√≥kemon, un n√∫mero para indicar una fuerza, un tipo de P√≥kemon y un n√∫mero
// para indicar un nivel, indica si en la lista dada existe algun P√≥kemon de ese tipo
// con esa fuerza y ese nivel.

function existeP√≥kemonEn_ConFuerza_Tipo_YNivel_(p√≥kemons, fuerza, tipo, nivel) {
    /*
        PROP√ìSITO:
            * Indica si existe un p√≥kemon del tipo dado, con la fuerza dada y el nivel dado, en la lista de p√≥kemons dada. 
        PAR√ÅMETROS:
            * p√≥kemons: [P√≥kemon]
            * fuerza: N√∫mero
            * tipo: tipoDeP√≥kemon
            * nivel: N√∫mero
        TIPO: Booleano
        PRECONDICIONES:
            * **fuerza** debe ser >= 0.
            * **nivel**  debe ser >= 0.
        OBSERVACIONES:
            * Recorrido de b√∫squeda sobre la lista de p√≥kemons dada.
    */

    p√≥kemonsPorRecorrer := p√≥kemons 

    while (not esVac√≠a(p√≥kemonsPorRecorrer) && not _esDeTipo_ConFuerza_YNivel_(p√≥kemon, tipo, fuerza, nivel)) {
        p√≥kemonsPorRecorrer := resto(p√≥kemonsPorRecorrer)
    }
    
    return (not esVac√≠a(p√≥kemonsPorRecorrer))
}

function _esDeTipo_ConFuerza_YNivel_(p√≥kemon, tipoDado, fuerzaDada, nivelDado) {
    /*
        PROP√ìSITO:
            * Indica si el p√≥kemon dado es de tipo **tipoDado**, con fuerza **fuerzaDada** y nivel **nivelDado**.
        PAR√ÅMETROS:
            * p√≥kemon: P√≥kemon
            * tipoDado: tipoDeP√≥kemon
            * fuerzaDada: N√∫mero
            * nivelDado: N√∫mero
        TIPO: Booleano
        PRECONDICIONES:
            * **fuerza** debe ser >= 0.
            * **nivel**  debe ser >= 0.
    */
    
    return (tipo(p√≥kemon) == tipoDado && fuerza(p√≥kemon) == fuerzaDada && nivel(p√≥kemon) == nivelDado)
}

// FUNCIONES AUXILIARES üê±‚Äçüèç

function unoSi_CeroSino(condici√≥n) {
    /*
        PROP√ìSITO:
            * Describe 1 si se cumple la condici√≥n dada; describe 0 en caso contrario.
        PAR√ÅMETROS:
            * condici√≥n: Booleano
        TIPO: N√∫mero (0 o 1)
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (choose 1 when (condici√≥n)
                   0 otherwise
    )
}
