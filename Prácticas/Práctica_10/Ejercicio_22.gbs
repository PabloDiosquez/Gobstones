// 22. Construir las siguientes funciones:
// a. m√≠nimoElementoDe_, que dada una lista de N√∫meros, describe el elemento
// m√°s chico que se encuentra en la lista. ¬øCu√°l es la precondici√≥n de la funci√≥n?
// Por ejemplo, m√≠nimoElementoDe_([13,21,3,9,45,3,7]) describe 3.
// b. sinElM√≠nimoElemento_, que dada una lista de N√∫meros, describe la lista que
// se obtiene de eliminar una √∫nica vez el elemento m√°s chico. ¬øCu√°l es la
// precondici√≥n de la funci√≥n?
// Por ejemplo, sinElM√≠nimoElemento_([13,21,3,9,45,3,7]) describe
// [13,21,9,45,3,7].
// c. lista_ordenada, que dada una lista de N√∫meros, describe la lista con los
// mismos elementos que la dada, pero ordenada de menor a mayor. ¬øSe puede elaborar una estrategia combinando los ejercicios anteriores?
// Por ejemplo, lista_ordenada([13,21,3,9,45,17,8,3,7]) describe
// [3,3,7,8,9,13,17,21,45].

// a.

function m√≠nimoElementoDe_(lista) {
    /*
        PROP√ìSITO:
            * Describe el elemento m√°s chico de la lista dada.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: Elemento
        PRECONDICIONES:
            * La lista dada no debe ser vac√≠a.
    */
    
    m√≠nimoAlMomento := primero(elementosPorRecorrer)

    foreach elemento in lista {
        m√≠nimoAlMomento := m√≠nimoEntre_Y_(m√≠nimoAlMomento, elemento)
    }

    return (m√≠nimoAlMomento)
}

// b.

function sinElM√≠nimoElemento_(lista) {
    /*
        PROP√ìSITO:
            * Describe la lista que resulta de eliminar una √∫nica vez el elemento m√°s chico de la lista dada.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: [Elemento]
        PRECONDICIONES:
            * La lista dada no debe ser vac√≠a.
    */
    
    return (sinLaPrimeraAparici√≥nDe_en_(m√≠nimoElementoDe_(lista), lista))
}

// c.

function lista_ordenada(lista) {
    /*
        PROP√ìSITO:
            * Describe la lista con los mismos elementos que la dada, pero ordenada de menor a mayor.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: [Elemento]
        PRECONDICIONES:
            * No tiene (es una fucni√≥n total).
        OBSERVACIONES:
            * La lista vac√≠a est√° ordenada.
    */
    
    elementosPorRecorrer := lista

    elementosOrdenadosAlMomento := []

    while (not esVac√≠a(elementosPorRecorrer)) {
        elementosOrdenadosAlMomento := elementosOrdenadosAlMomento ++ [m√≠nimoElementoDe_(elementosPorRecorrer)]

        elementosPorRecorrer := sinElM√≠nimoElemento_(elementosPorRecorrer)
    }

    return (elementosOrdenadosAlMomento)
}

// FUNCIONES AUXILIARES üê±‚Äçüèç

function m√≠nimoEntre_Y_(elemento1, elemento2) {
    /*
        PROP√ìSITO:
            * Describe el elemento m√°s chico entre los dos elementos dados.
        PAR√ÅMETROS:
            * elemento1: Elemento
            * elemento2: Elemento
        TIPO: Elemento
        PRECONDICIONES:
            * Los elementos dados deben ser del mismo tipo.
    */
    
    return (choose elemento1 when (elemento1 <= elemento2)
                   elemento2 otherwise 
    )
}