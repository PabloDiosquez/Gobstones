// 22. Construir las siguientes funciones:
// a. m√≠nimoElementoDe_, que dada una lista de N√∫meros, describe el elemento
// m√°s chico que se encuentra en la lista. ¬øCu√°l es la precondici√≥n de la funci√≥n?
// Por ejemplo, m√≠nimoElementoDe_([13,21,3,9,45,3,7]) describe 3.
// b. sinElM√≠nimoElemento_, que dada una lista de N√∫meros, describe la lista que
// se obtiene de eliminar una √∫nica vez el elemento m√°s chico. ¬øCu√°l es la
// precondici√≥n de la funci√≥n?
// Por ejemplo, sinElM√≠nimoElemento_([13,21,3,9,45,3,7]) describe
// [13,21,9,45,3,7].
// c. lista_ordenada, que dada una lista de N√∫meros, describe la lista con los
// mismos elementos que la dada, pero ordenada de menor a mayor. ¬øSe puede elaborar una estrategia combinando los ejercicios anteriores?
// Por ejemplo, lista_ordenada([13,21,3,9,45,17,8,3,7]) describe
// [3,3,7,8,9,13,17,21,45].

// a.

function m√≠nimoElementoDe_(lista) {
    /*
        PROP√ìSITO:
            * Describe el elemento m√°s chico de la lista dada.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: Elemento
        PRECONDICIONES:
            * La lista dada no debe ser vac√≠a.
    */
    
    m√≠nimoAlMomento := primero(elementosPorRecorrer)

    foreach elemento in lista {
        m√≠nimoAlMomento := m√≠nimoEntre_Y_(m√≠nimoAlMomento, elemento)
    }

    return (m√≠nimoAlMomento)
}




// FUNCIONES AUXILIARES üê±‚Äçüèç

function m√≠nimoEntre_Y_(elemento1, elemento2) {
    /*
        PROP√ìSITO:
            * Describe el elemento m√°s chico entre los dos elementos dados.
        PAR√ÅMETROS:
            * elemento1: Elemento
            * elemento2: Elemento
        TIPO: Elemento
        PRECONDICIONES:
            * Los elementos dados deben ser del mismo tipo.
    */
    
    return (choose elemento1 when (elemento1 <= elemento2)
                   elemento2 otherwise 
    )
}