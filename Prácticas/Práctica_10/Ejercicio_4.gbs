// Construir el procedimiento Poner_Bolitas_EnElTablero, que dada una lista de
// n√∫meros y un color, recorre el tablero con direcci√≥n principal Norte y direcci√≥n
// secundaria Oeste y pone en cada celda la cantidad de bolitas del color dado, seg√∫n el
// elemento en la posici√≥n correspondiente. Si hubiera menos n√∫meros que celdas, en las
// celdas restantes no se pondr√°n bolitas, y si hubiera m√°s n√∫meros que celdas, se
// ignoran los n√∫meros sobrantes.

procedure Poner_Bolitas_EnElTablero(n√∫meros, color) {
    /*
        PROP√ìSITO:  
            * Pone en cada celda del tablero la cantidad de bolitas del color dado, seg√∫n el elemento en la posici√≥n correspondiente. Si hubiera menos n√∫meros que celdas, en las celdas restantes no se pondr√°n bolitas y si hubiera m√°s n√∫meros que celdas, se ignoran los n√∫meros sobrantes.
        PAR√ÅMETROS:
            * n√∫meros: [N√∫mero]
            * color:    Color
        PRECONDICIONES:
            * Los n√∫meros de la lista de n√∫meros dada deben ser >= 0.
        OBSERVACIONES:
            * Recorrido de procesamiento sobre la lista dada.
    */

        n√∫merosPorMirar := n√∫meros

        IrAPrimeraCeldaEnUnRecorridoAl_Y_(Norte, Oeste)

        while (haySiguienteCeldaEnUnRecorridoAl_Y_(Norte, Oeste) && not esVac√≠a(n√∫merosPorMirar)) {
            
            Poner_DeColor_(primero(n√∫merosPorMirar), color)

            n√∫merosPorMirar := resto(n√∫merosPorMirar)

            IrASiguienteCeldaEnUnRecorridoAl_Y_(Norte, Oeste)
        }

        Poner_BolitasDeColor_Si_(primero(n√∫merosPorMirar), color, not esVac√≠a(n√∫merosPorMirar)) // Caso borde üôä
}  

// FUNCIONES AUXILARES üê±‚Äçüèç

procedure Poner_DeColor_(cantidad, color) {
    /*
        PROP√ìSITO:
            * Pone **cantidad** bolitas de color **color** en la celda actual.
        PAR√ÅMETROS:
            * cantidad: N√∫mero.
            * color:    Color.
        PRECONDICIONES:
            * **cantidad** debe ser >= 0.
    */
    repeat (cantidad) {
        Poner(color)
    }
}

procedure Poner_BolitasDeColor_Si_(cantidad, color, condici√≥n) {
    /*
        PROP√ìSITO:
            * Pone **cantidad** de bolitas de color **color** si se cumple la condici√≥n dada.
        PAR√ÅMETROS:
            * cantidad: N√∫mero
            * color: Color
            * condici√≥n: Booleano
        PRECONDICIONES:
            * **cantidad** debe ser >= 0.
    */

    if (condici√≥n) {
        Poner_DeColor_(cantidad, color)
    }
    
}

procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Ubica el cabezal en el inicio de un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n - La primera direcci√≥n del recorrido.
            * dirSecundaria: Direcci√≥n - La segunda direcci√≥n del recorrido.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}

function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Indica si existe una celda siguiente en un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n - La primera direcci√≥n del recorrido.
            * dirSecundaria: Direcci√≥n - La segunda direcci√≥n del recorrido.
        TIPO: Booleano.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */  
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}

procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Mueve el cabezal a la siguiente celda de un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n - Describe la primera direcci√≥n del recorrido.
            * dirSecundaria: Direcci√≥n - Describe la segunda direcci√≥n del recorrido.
        PRECONDICIONES:
            * Debe existir al menos una celda siguiente en el recorrido.
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */
    if (puedeMover(dirPrincipal)){
        Mover(dirPrincipal)
    }
    else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}