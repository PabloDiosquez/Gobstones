// Ms. Gobs-Man es la secuela del popular juego de video argentino desarrollado en Gobstones, Gobs-Man. Ms.
// Gobs-Man incorpora una serie de caracter√≠sticas que se esperan transformen al juego en un √©xito inmediato.
// Esta vez el jugador se pondr√° en la piel de Ms.Gobs-Man, la versi√≥n femenina de nuestro aclamado h√©roe
// comecocos. Como en la primera versi√≥n del juego, el objetivo ser√° lograr que Ms. Gobs-Man se coma todos
// los cocos y las cerezas. Para ello contaremos con todas las primitivas que se presentaron en el primer juego,
// que ahora act√∫an sobre Ms.Gobs-Man, as√≠ como tambi√©n la siguiente, que se agrega a las anteriores:

function hayCoco()
// PROP√ìSITO: Indica cuando hay un coco en la celda actual.
// PRECONDICI√ìNES: Ninguna.

// Esta vez, sin embargo, tanto los cocos como las cerezas otorgar√°n puntaje al jugador.

// Ejercicio 10)
// Dado que el cabezal se encuentra en alguna celda, se espera poder determinar cu√°ntos puntos obtendr√° Ms.
// Gobs-Man si come todo lo que hay en dicha celda. Note que la celda puede tener un coco, una cereza, ambos
// o estar vac√≠a. Un coco otorga a Ms. Gobs-Man 100 puntos, y una cereza otorga 2000 puntos. Escriba la
// funci√≥n: puntajeAObtenerEnCeldaActual() que describe los puntos a obtener en la celda actual.

function puntajeAObtenerEnCeldaActual() {
    /*
        PROP√ìSITO:
            * Describe el puntaje que obtiene Ms. GobsMan si come todo lo que hay la celda actual.
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * La celda puede tener un coco, una cereza, ambos o estar vac√≠a.
            * Un coco otorga 100 puntos y una cereza otorga 2000.
    */
    
    return (choose 2100 when (hayCoco() && hayCereza())
                   2000 when (hayCereza())
                   100  when (hayCoco())
                   0    otherwise 
    )
}

// Ejercicio 11)
// Se nos plantea ahora que adem√°s de cerezas y cocos, las celdas pueden contener frutillas (O fresas, si
// prefiere). Las frutillas otorgan 500 puntos solamente, pero pueden encontrarse en cualquier celda.
// Debe replantear la funci√≥n puntajeAObtenerEnCeldaActual() para tener en cuenta dicha situaci√≥n. Si su
// estrategia anterior fue buena, entonces este cambio no deber√≠a redundar en demasiado trabajo. Si por el
// contrario la soluci√≥n no fue buena, le llevar√° m√°s esfuerzo (Si fuera este √∫ltimo caso, lo invitamos a repensar
// si est√° separando el problema en las subtareas correctas, o ver si puede realizar m√°s). Ah, por cierto, casi se
// nos olvida, tambi√©n cuenta con la primitiva siguiente:

function hayFrutilla()
// PROP√ìSITO: Indica cuando hay una frutilla en la celda actual.
// PRECONDICI√ìNES: Ninguna.

// Atenci√≥n: Piense si su soluci√≥n escala correctamente si hubieran otras tres posibles frutas (ej. naranjas,
// bananas y manzanas)

function puntajeAObtenerEnCeldaActual() {
    /*
        PROP√ìSITO:
            * Describe el puntaje que obtiene Ms. GobsMan si come todo lo que hay la celda actual.
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * La celda puede tener un coco, una cereza, ambos o estar vac√≠a.
            * Un coco otorga 100 puntos y una cereza otorga 2000.
    */
    
    return (choose 2600 when  (hayCoco() && hayCereza() && hayFrutilla())
                   2500 when  (hayCereza() && hayFrutilla())
                   2100 when  (hayCoco() && hayCereza())
                   600  when  (hayCoco () && hayFrutilla())
                   2000 when  (hayCereza())
                   500  when  (hayFrutilla())
                   100  when  (hayCoco())
                   0    otherwise
    )
}

// Ejercicio 12)
// Por cierto, para mostrar esos cuadraditos verdes con los puntos que vimos en los ejemplos anteriores se
// utiliz√≥ una muy √∫til primitiva que nos proporcionaron:

procedure Mostrar_PuntosEnPantalla(cantidadDePuntosAMostrar)
// PROP√ìSITO: Muestra en la pantalla la cantidad de puntos dados como
// argumento.
// OBSERVACI√ìN: Los puntos se muestran como un n√∫mero en un recuadro verde
// en la esquina de la celda.
// PRECONDICI√ìNES:
// * No debe haber elementos para comer en la celda actual.
// * El cabezal se encuentra sobre Ms. Gobs-Man.
// PAR√ÅMETROS:
// * cantidadDePuntosAMostrar: N√∫mero - Los puntos a mostrar en la pantalla.

// Ahora queremos asegurarnos de poder mostrar los puntos correspondientes a lo que Ms. Gobs-Man
// efectivamente vaya a comer en la celda actual.
// Se espera que usted cree el procedimiento ComerLoQueHayEnLaCeldaYMostrarPuntos() que haga que
// Ms. Gobs-Man coma todo lo que hay en la celda en donde est√° parada, y que se muestre en dicha celda los
// puntos que se obtienen tras comer lo que all√≠ hab√≠a.
// Probablemente necesite tambi√©n del procedimiento siguiente como primitiva:

procedure ComerFrutilla()
// PROP√ìSITO: Come la frutilla de la celda actual.
// PRECONDICI√ìNES:
// * Hay una frutilla en la celda actual.
// * El cabezal se encuentra sobre Ms. Gobs-Man

procedure ComerLoQueHayEnLaCeldaYMostrarPuntos() {
    /*
        PROP√ìSITO:
            * Ms. GobsMan come todo lo que hay en la celda actual y se muestra en dicha celda los puntos obtenidos tras comer todo lo que hay ah√≠.
        PRECONDICIONES:
            * Ms. GobsMan debe estar en la celda actual.
    */
    puntajeAObtenerEnLaCeldaActual := puntajeAObtenerEnCeldaActual()
    ComerCocoSiHay()
    ComerCerezaSiHay()
    ComerFrutillaSiHay()
    Mostrar_PuntosEnPantalla(puntajeAObtenerEnLaCeldaActual)
}

procedure ComerCocoSiHay() {
    /*
        PROP√ìSITO:
            * Ms. GobsMan come un coco si hay en la celda actual.
        PRECONDICIONES:
            * Ms. GobsMan est√° en la celda actual.
    */
    if(hayCoco()){
        ComerCoco()
    }
}

procedure ComerCerezaSiHay() {
    /*
        PROP√ìSITO:
            * Ms. GobsMan come una cereza si hay en la celda actual.
        PRECONDICIONES:
            * Ms. GobsMan est√° en la celda actual.
    */
    if(hayCereza()){
        ComerCereza()
    }
}

procedure ComerFrutillaSiHay() {
    /*
        PROP√ìSITO:
            * Ms. GobsMan come una cereza si hay en la celda actual..
        PRECONDICIONES:
            * Ms. GobsMan est√° en la celda actual.
    */
    if(hayFrutilla()){
        ComerFrutilla()
    }
}

// Ejercicio 13)
// Se desea saber cu√°ntos puntos es posible obtener en un nivel determinado. Esto depender√° por supuesto de
// la cantidad de celdas que haya en dicho nivel, as√≠ como de que haya en cada celda (cocos, cerezas, frutillas,
// combinaciones de estas o nada). Se pide entonces realice la funci√≥n cantidadDePuntosEnElNivel()
// que indique la cantidad total de puntos que se pueden obtener en el nivel. Por ejemplo, en el siguiente nivel se
// obtienen 18700 puntos (considerando que en el lugar en donde inicia Ms. Gobs-Man no hay nada). Puede
// asumir que el cabezal se encuentra sobre Ms. Gobs-Man.

// Atenci√≥n: Para calcular los puntos no es necesario mover a Ms. Gobs-Man, sino s√≥lo el cabezal. Sin embargo,
// si movemos a Ms. Gobs-Man tampoco representar√° un problema, pues las funciones no tienen efecto, sino
// que describen valores.

function cantidadDePuntosEnElNivel() {
    /*
        PROP√ìSITO:
            * Describe la cantidad de puntos que se pueden obtener en el nivel dado.
        TIPO: N√∫mero.
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACIONES:
            * Recorrido de acumulaci√≥n sobre las celdas del nivel, acumulando la cantidad de puntos que se pueden obtener en cada celda.
    */
    
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    puntajeAlMomento := puntajeAObtenerEnCeldaActual()
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
        puntajeAlMomento:= puntajeAlMomento + puntajeAObtenerEnCeldaActual()
    }
    return (puntajeAlMomento)
}

// Ejercicio 14)
// Es interesante poder determinar si Ms. Gobs-Man va a morir a causa de cruzarse con un fantasma o no
// (Recordemos que en un nivel puede o no haber fantasmas). Se desea entonces la funci√≥n
// hayAlg√∫nFantasmaEnElNivel() que indica si hay un fantasma en el nivel. Por cierto, puede asumir que el
// cabezal se encuentra sobre Ms. Gobs-Man.
// Pista: Esta funci√≥n es muy parecida a buscar un fantasma y luego morir, pero en lugar de morir debo indicar si
// encontr√© o no el fantasma. Note que no necesita variables para resolver el problema.

function hayAlg√∫nFantasmaEnElNivel() {
    /*
        PROP√ìSITO:
            * Indica si hay alg√∫n fantasma en el nivel.
        TIPO: Booleano
        PRECONDICIONES:
            * El cabezal se encuentra sobre Ms. GobsMan.
    */
    
    IrAPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while(haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte) && not hayFantasma()){
        IrASiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    return (hayFantasma())
}

// Ejercicio 15)
// Como Ms. Gobs-Man puede cruzarse con un fantasma en el camino, y en ese caso, el juego termina en ese
// momento. Es decir, los puntos totales que acumula Ms. Gobs-Man en un nivel no siempre son el total de las
// cosas que hay en el tablero, sino solamente aquellas que ‚Äúcome‚Äù hasta que encuentra el fantasma, si es que
// hubiera uno. En ese sentido, las direcciones hacia las cuales Ms. Gobs-Man realiza un recorrido comiendo lo
// que encuentra es importante. Si parte de la celda Sur-Oeste y se mueve primero al Este y luego al Norte, podr√≠a
// conseguir menos puntos (o m√°s) que si parte de la celda Norte-Este y se mueve al Sur y al Oeste, por poner un
// ejemplo.
// Por eso es interesante poder calcular cu√°ntos puntos obtendr√° Ms. Gobs-Man hasta toparse con un fantasma
// (si hubiera uno), si realiza un recorrido en dos direcciones determinadas, dadas por par√°metro.
// Se pide escriba cantidadDePuntosEnNivelHacia_Y_(direcci√≥nPrincipal,
// direcci√≥nSecundaria), una funci√≥n que dadas dos direcciones indica cu√°ntos puntos acumular√≠a
// Ms.Gobs-Man en un recorrido en dicha direcci√≥n. Nuevamente, el cabezal arranca sobre Ms. Gobs-Man.
// En el ejemplo siguiente, si el recorrido se realiza hacia el Este y el Sur (partiendo de la esquina Norte-Oeste)
// solo se obtendr√°n 2900 puntos, mientras que si se realiza hacia el Oeste y el Sur (partiendo de la esquina
// Norte-Este) se obtendr√°n 5000. Otras direcciones dar√°n otros puntajes.

function cantidadDePuntosEnNivelHacia_Y_(direcci√≥nPrincipal, direcci√≥nSecundaria) {
    /*
        PROP√ìSITO:
            * Describe la cantidad de puntos que obtendr√≠a Ms. GobsMan en un recorrido de direcciones **direcci√≥nPrincipal** y **direcci√≥nSecundaria**.
        PAR√ÅMETROS:
            * direcci√≥nPrincipal: Direcci√≥n
            * direcci√≥nSecundaria: Direcci√≥n
        TIPO: N√∫mero.
        PRECONDICIONES:
            * El cabezal se encuentra sobre Ms. GobsMan.
        OBSERVACIONES:
            * Recorrido de acumulaci√≥n sobre las celdas del tablero, calculando el puntaje total obtenido por Ms. GobsMan al recorrer el nivel de una manera determinada.
    */

    IrAPrimeraCeldaEnUnRecorridoAl_Y_(direcci√≥nPrincipal, direcci√≥nSecundaria)
    puntajeAlMomento := puntajeAObtenerEnCeldaActual()
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(direcci√≥nPrincipal, direcci√≥nSecundaria) && not hayFantasma()) {
        IrASiguienteCeldaEnUnRecorridoAl_Y_(direcci√≥nPrincipal, direcci√≥nSecundaria)
        puntajeAlMomento := puntajeAlMomento + puntajeAObtenerEnCeldaActual()
    }
    return (puntajeAlMomento)
}

// Ejercicio 16)
// Se desea saber cu√°l de dos opciones de recorridos es m√°s conveniente realizar. Por ejemplo, es mejor
// recorrer hacia el Norte y el Este, que hacia el Sur y el Este (siempre considerando mejor aquel recorrido en
// donde se obtienen m√°s puntos). Para determinarlo, se pide que escriba la funci√≥n
// esMejorRecorridoHacia_Y_QueHacia_Y_(dirPrincipal1, dirSecundaria1, dirPrincipal2,
// dirSecundaria2) que indica si un recorrido en dirPrincipal1 y dirSecundaria1 acumula efectivamente m√°s
// puntos que un recorrido en dirPrincipal2 y dirSecundaria2.
// Si consideramos el ejemplo anterior, la funci√≥n llamada como
// esMejorRecorridoHacia_Y_QueHacia_Y_(Este, Sur, Oeste, Sur) describe Falso, pues en el
// recorrido Este Sur se acumulaban solo 2900 puntos, mientras que en el Oeste-Sur eran 5000.
// esMejorRecorridoHacia_Y_QueHacia_Y_(Oeste, Sur, Este, Sur) describe Verdadero por la
// misma raz√≥n.

function esMejorRecorridoHacia_Y_QueHacia_Y_(dirPrincipal1, dirSecundaria1, dirPrincipal2, dirSecundaria2) {
    /*
        PROP√ìSITO:
            * Indica si el recorrido de direcciones **dirPrincipal1** y **dirSecundaria1** acumula m√°s puntos que un recorrido de direcciones **dirPrincipal2** y **dirSecundaria2**.
        PAR√ÅMETROS:
            * dirPrincipal1: Direcci√≥n
            * dirSecundaria1: Direcci√≥n
            * dirPrincipal2: Direcci√≥n
            * dirSecundaria2: Direcci√≥n
        TIPO: Booleano
        PRECONDICIONES:
            * ....
    */
    
    return (cantidadDePuntosEnNivelHacia_Y_(dirPrincipal1, dirSecundaria1) > cantidadDePuntosEnNivelHacia_Y_(dirPrincipal2, dirSecundaria2))
}

// Ejercicio 17)
// Queremos tambi√©n poder determinar si Ms. Gobs-Man ha logrado llegar a un punto en donde est√° cerca de
// finalizar el nivel, en particular, si complet√≥ m√°s de la mitad del mismo.
// Para esto, se le pide implementar la funci√≥n m√°sDeLaMitadDelNivelSiVaHacia_Y_(dirPrincipal,
// dirSecundaria) que indica si Ms. Gobs-Man pas√≥ m√°s de la mitad del nivel recorriendo hacia dirPrincipal y
// dirSecundaria. Note que sabemos nuevamente que el cabezal est√° sobre Ms. Gobs-Man, y tambi√©n contamos
// con esta √∫til primitiva:

function tama√±oDelTablero()
// PROP√ìSITO: Denota el n√∫mero total de celdas del tablero (nxm)
// PRECONDICI√ìN: Ninguna

// Ayuda: Ten√© en cuenta que Ms.Gobs-Man viene de las direcciones opuestas a aquellas hacia las cuales est√°
// recorriendo, y queremos saber cu√°ntas celdas ya visit√≥.

function m√°sDeLaMitadDelNivelSiVaHacia_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Indica si Ms. GobsMan p√°so m√°s de la mitad del nivel recorriendo hacia el **dirPrincipal** y el **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n
            * dirSecundaria: Direcci√≥n
        TIPO: Booleano
        PRECONDICIONES:
            * El cabezal est√° sobre Ms. GobsMan.
            * Las direcciones dadas no debe ser ni iguales ni opuestas.
    */
    
    return (cantidadDeCeldasRecorridasAlMomentoEnUnRecorridoAl_Y_(dirPrincipal, direcci√≥nSecundaria) > (tama√±oDelTablero() div 2))
}

function cantidadDeCeldasRecorridasAlMomentoEnUnRecorridoAl_Y_(dirPrincipal, direcci√≥nSecundaria) {
    /*
        PROP√ìSITO:
            * Describe la cantidad de celdas recorridas por Ms. GobsMan desde el inicio del recorrido hasta llegar a la celda actual.
        TIPO: N√∫mero
        PRECONDICIONES:
            * El cabezal est√° sobre Ms. GobsMan.
    */

    cantidadDeCeldasRecorridasAlMomento := 0
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(opuesto(dirPrincipal), opuesto(dirSecundaria))) {
        cantidadDeCeldasRecorridasAlMomento := cantidadDeCeldasRecorridasAlMomento + 1
        IrASiguienteCeldaEnUnRecorridoAl_Y_(opuesto(dirPrincipal), opuesto(direcci√≥nSecundaria))
    }
    return (cantidadDeCeldasRecorridasAlMomento + 1)
}

// Ejercicio 19)
// No todo es diversi√≥n al programar a Ms.Gobs-Man, porque tambi√©n tenemos que programar a los malos. En
// este caso el cabezal se encuentra sobre un fantasma, y queremos mover al fantasma hacia donde est√° Ms.
// Gobs-Man. Para ello, debemos calcular d√≥nde est√° Ms.Gobs-Man y determinar hacia d√≥nde mover el
// fantasma. Para ello contamos con las siguientes primitivas:

procedure PararCabezalEnMsGobsMan()
// PROP√ìSITO: Posiciona el cabezal sobre Ms. Gobs-Man.
// PRECONDICI√ìN: Ms. Gobs-Man est√° viva en el tablero.

procedure MoverFantasmaAl_(direcci√≥n)
// PROP√ìSITO: Mueve al fantasma de la celda actual una celda hacia la
// direcci√≥n dada.
// PRECONDICI√ìN: El cabezal se encuentra sobre un fantasma.
// PAR√ÅMETRO:
// * direcci√≥n: Direcci√≥n - La direcci√≥n a la cual mover el fantasma.

// Se pide entonces que realice el procedimiento MoverFantasmaHaciaMsGobsMan() que mueve el fantasma
// hacia Ms.Gobs-Man una celda, utilizando el siguiente criterio.
// ‚óè Si Ms. Gobs-Man se encuentra en una fila y columna distinta a la del fantasma, mueve el fantasma
// en diagonal hacia las direcciones en las que se encuentre Ms.Gobs-Man.
// ‚óè Si Ms.Gobs-Man se encuentra en la misma fila que el fantasma, solo lo mueve una celda sobre la
// columna actual, en direcci√≥n a Ms.Gobs-Man.
// ‚óè Si Ms.Gobs-Man se encuentra en la misma columna que el fantasma, solo lo mueve una celda sobre la
// columna actual, en direcci√≥n a Ms.Gobs-Man.

// Realizar ese procedimiento no es f√°cil, y es conveniente descomponer el problema en tareas mucho m√°s
// peque√±as y simples. Es por eso que nuestro equipo de analistas ya ha planteado una serie de funciones que
// pueden serle √∫tiles para solucionar el problema usando una estrategia top-down. A saber, se espera utilice
// estas funciones (y las implemente) para solucionar el procedimiento anteriormente mencionado:

// ‚óè elFantasmaDebeMoverseHorizontalmente() que indica si el fantasma no se encuentra en la
// misma columna que Ms. Gobs-Man.
// ‚óè elFantasmaDebeMoverseVerticalmente() que indica si el fantasma no se encuentra en la misma
// fila que Ms. Gobs-Man.
// ‚óè direcci√≥nHorizontalAMoverElFantasma() que dado que el fantasma no est√° en la misma
// columna que Ms. Gobs-Man, describe la direcci√≥n a la cual el fantasma se deber√≠a mover para quedar
// m√°s cerca que Ms. Gobs-Man en t√©rminos de columnas (Este u Oeste).
// ‚óè direcci√≥nVerticalAMoverElFantasma() que dado que el fantasma no est√° en la misma fila que
// Ms. Gobs-Man, describe la direcci√≥n a la cual el fantasma se deber√≠a mover para quedar m√°s cerca
// que Ms. Gobs-Man en t√©rminos de filas (Norte o Sur).

function elFantasmaDebeMoverseHorizontalmente() {
    /*
        PROP√ìSITO:
            * Indica si el fantasma no se encuentra en la misma columna que Ms. GobsMan.
        TIPO: Booleano
        PRECONDICIONES:
            * El cabezal debe estar sobre el fantasma.
    */
    
    return (columnaDondeEst√°ElFantasma() /= columnaDondeEst√°MsGobsMan())
}

function elFantasmaDebeMoverseVerticalmente() {
    /*
        PROP√ìSITO:
            * Indica si el fantasma no se encuentra en la misma fila que Ms. GobsMan.
        TIPO: Booleano
        PRECONDICIONES:
            * El cabezal debe estar sobre el fantasma.
    */
    
    return (filaDondeEst√°ElFantasma() /= filaDondeEst√°MsGobsMan())
}

function direcci√≥nHorizontalAMoverElFantasma() {
    /*
        PROP√ìSITO:
            * Describe la direcci√≥n a la cual el fantasma debe moverse para quedar m√°s cerca de Ms. GobsMan en t√©rminos de columnas (Este u Oeste). 
        TIPO: Direcci√≥n
        PRECONDICIONES:
            * El cabezal debe estar sobre el fantasma.
            * El fantasma no est√° en la misma columna que Ms. GobsMan.
    */
    
    return (choose Este  when (columnaDondeEst√°ElFantasma() < columnaDondeEst√°MsGobsMan())
                   Oeste otherwise
    )
}

function direcci√≥nVerticalAMoverElFantasma() {
    /*
        PROP√ìSITO:
            * Describe la direcci√≥n a la cual el fantasma debe moverse para quedar m√°s cerca de Ms. GobsMan en t√©rminos de filas (Norte o Sur). 
        TIPO: Direcci√≥n
        PRECONDICIONES:
            * El cabezal debe estar sobre el fantasma.
            * El fantasma no est√° en la misma fila que Ms. GobsMan.
    */
    
    return (choose Norte when (filaDondeEst√°ElFantasma() < filaDondeEst√°MsGobsMan())
                   Sur   otherwise
    )
}

// A su vez, se recomienda realizar las siguientes funciones para solucionar las anteriores:
// ‚óè filaDondeEst√°ElFantasma() que describe el n√∫mero de fila donde se encuentra el fantasma.
// ‚óè columnaDondeEst√°ElFantasma() que describe el n√∫mero de columna donde se encuentra el
// fantasma.
// ‚óè filaDondeEst√°MsGobsMan() que describe el n√∫mero de fila donde se encuentra Ms.Gobs-Man.
// ‚óè columnaDondeEst√°MsGobsMan() que describe el n√∫mero de columna donde se encuentra Ms.
// Gobs-Man.

function filaDondeEst√°ElFantasma() {
    /*
        PROP√ìSITO:
            * Describe el n√∫mero de fila en donde se encuentra el fantasma.
        TIPO: N√∫mero
        PRECONDICIONES:
            * El cabezal est√° sobre el fantasma.
    */

    n√∫meroDeFilaAlMomento := 0
    while(puedeMover(Sur)){
        n√∫meroDeFilaAlMomento := n√∫meroDeFilaAlMomento + 1
        Mover(Sur)
    }
    return (n√∫meroDeFilaAlMomento)
}

function columnaDondeEst√°ElFantasma() {
    /*
        PROP√ìSITO:
            * Describe el n√∫mero de columna en donde se encuentra el fantasma.
        TIPO: N√∫mero
        PRECONDICIONES:
            * El cabezal est√° sobre el fantasma.
    */
    
    n√∫meroDeColumnaAlMomento := 0
    while(puedeMover(Oeste)){
        n√∫meroDeColumnaAlMomento := n√∫meroDeColumnaAlMomento + 1
        Mover(Oeste)
    }
    return (n√∫meroDeColumnaAlMomento)
}

function filaDondeEst√°MsGobsMan() {
    /*
        PROP√ìSITO: 
            * Describe el n√∫mero de fila donde se encuentra Ms. GobsMan.
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */

    PararCabezalEnMsGobsMan()
    n√∫meroDeFilaAlMomento := 0
    while(puedeMover(Sur)){
        n√∫meroDeFilaAlMomento := n√∫meroDeFilaAlMomento + 1
        Mover(Sur)
    }
    return (n√∫meroDeFilaAlMomento)
}

function columnaDondeEst√°MsGobsMan() {
    /*
        PROP√ìSITO: 
            * Describe el n√∫mero de columna donde se encuentra Ms. GobsMan.
        TIPO: N√∫mero
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */

    PararCabezalEnMsGobsMan()
    n√∫meroDeColumnaAlMomento := 0
    while(puedeMover(Oeste)){
        n√∫meroDeColumnaAlMomento := n√∫meroDeColumnaAlMomento + 1
        Mover(Oeste)
    }
    return (n√∫meroDeColumnaAlMomento)
}


// FUNCIONES AUXILIARES üê±‚Äçüèç

// a.
procedure IrAPrimeraCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Ubica el cabezal en el inicio de un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n - La primera direcci√≥n del recorrido.
            * dirSecundaria: Direcci√≥n - La segunda direcci√≥n del recorrido.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */
    IrAlBorde(opuesto(dirPrincipal))
    IrAlBorde(opuesto(dirSecundaria))
}

// b.
function haySiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Indica si existe una celda siguiente en un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n - La primera direcci√≥n del recorrido.
            * dirSecundaria: Direcci√≥n - La segunda direcci√≥n del recorrido.
        TIPO: Booleano.
        PRECONDICIONES:
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */  
    return (puedeMover(dirPrincipal) || puedeMover(dirSecundaria))
}

// c.
procedure IrASiguienteCeldaEnUnRecorridoAl_Y_(dirPrincipal, dirSecundaria) {
    /*
        PROP√ìSITO:
            * Mueve el cabezal a la siguiente celda de un recorrido de direcciones **dirPrincipal** y **dirSecundaria**.
        PAR√ÅMETROS:
            * dirPrincipal: Direcci√≥n - Describe la primera direcci√≥n del recorrido.
            * dirSecundaria: Direcci√≥n - Describe la segunda direcci√≥n del recorrido.
        PRECONDICIONES:
            * Debe existir al menos una celda siguiente en el recorrido.
            * Las direcciones dadas no deben ser ni iguales ni opuestas.
    */
    if (puedeMover(dirPrincipal)){
        Mover(dirPrincipal)
    }
    else {
        IrAlBorde(opuesto(dirPrincipal))
        Mover(dirSecundaria)
    }
}