// Construir la funci√≥n est√°Ordenada_ que, dada una lista de n√∫meros indica si est√°
// ordenada de menor a mayor. Para que una lista est√© ordenada, cada elemento debe ser
// menor o igual al que le sigue.
// Por ejemplo, la expresi√≥n est√°Ordenada_([2,7,9,15]) indica verdadero, mientras
// que la expresi√≥n est√°Ordenada_([2,15,9,7]) indica falso.

function est√°Ordenada_(lista) {
    /*
        PROP√ìSITO: 
            * Indica si la lista dada est√° ordenada de menor a mayor.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
        OBSERVACI√ìN:
            * La lista vac√≠a est√° ordenada. üê∏
    */

    elementosPorRecorrer := lista 

    while (not esVac√≠a(elementosPorRecorrer) && m√≠nimoDe_(elementosPorRecorrer) == primero(elementosPorRecorrer)) {
        
        elementosPorRecorrer := resto(elementosPorRecorrer)
    }
    
    return (esVac√≠a(elementosPorRecorrer))
}

// FUNCIONES AUXILIARES üê±‚Äçüèç

function m√≠nimoDe_(lista) {
    /*
        PROP√ìSITO:
            * Describe el m√≠nimo elemento de la lista dada.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: Elemento
        PRECONDICIONES:
            * La lista dada no debe ser vac√≠a.
    */
    
    m√≠nimoHastaAhora := primero(lista)

    foreach elemento in lista {
        m√≠nimoHastaAhora := m√≠nimoEntre_Y_(m√≠nimoHastaAhora, elemento)
    }

    return (m√≠nimoHastaAhora)
}

function m√≠nimoEntre_Y_(elemento1, elemento2) {
    /*
        PROP√ìSITO: 
            * Describe el m√≠nimo entre los elementos dados.
        PAR√ÅMETROS:
            * elemento1: Elemento
            * elemento2: Elemento
        TIPO: Elemento
        PRECONDICIONES:
            * Los elementos dados deben ser del mismo tipo.
    */
    
    return (choose elemento1 when (elemento1 <= elemento2)
                   elemento2 otherwise 
        )
}

// VERSI√ìN ALTERNATIVA üéâ
// ¬øLa soluci√≥n propuesta requiri√≥ el uso de variables que recuerdan valores booleanos?
// Si fue as√≠, considerar ofrecer una soluci√≥n que NO utilice variables booleanas.

function est√°Ordenada_(lista) {
    /*
        PROP√ìSITO: 
            * Indica si la lista dada est√° ordenada de menor a mayor.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: Booleano
        PRECONDICIONES:
            * La lista dada no debe ser vac√≠a.
    */
    
    elementosPorRecorrer := lista

    while (not esSingular_(elementosPorRecorrer) && primero(elementosPorRecorrer) <= segundo(elementosPorRecorrer)) {
        elementosPorRecorrer := resto(elementosPorRecorrer)
    }

    return (esSingular_(elementosPorRecorrer))
}

function esSingular_(lista) {
    /*
        PROP√ìSITO:
            * Indica si la lista dada est√° formada por un √∫nico elemento.
        PAR√ÅMETROS:
            *lista: [Elemento]
        TIPO: Booleano
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (not esVac√≠a(lista) && esVac√≠a(resto(lista)))
}

function segundo(lista) {
    /*
        PROP√ìSITO:
            * Describe el segundo elemento de la lista dada.
        PAR√ÅMETROS:
            * lista: [Elemento]
        TIPO: Elemento
        PRECONDICIONES:
            * La lista dada debe tener al menos dos elementos.
    */
    
    return (primero(resto(lista)))
}