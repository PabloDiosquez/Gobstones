// ATENCI√ìN: No tiene que implementar las primitivas salvo que as√≠ lo indique el enunciado, pero si puede hacer
// uso de ellas para solucionar todos los problemas planteados.

// Primitivas ü§≤üèº

// procedure MoverGobsManAl_(direcci√≥n)
// PROP√ìSITO: Mueve a Gobs-Man a la celda vecina en la direcci√≥n ‚Äúdirecci√≥n‚Äù.
// El cabezal queda sobre Gobs-Man.
// PRECONDICI√ìNES:
// * Existe una celda vecina en direcci√≥n ‚Äúdirecci√≥n‚Äù.
// * El cabezal se encuentra sobre Gobs-Man.
// PAR√ÅMETROS:
// * direcci√≥n: Direcci√≥n - Indica hacia d√≥nde se mover√° Gobs-Man.

// procedure LlevarGobsManAlBorde_(direcci√≥n)
// PROP√ìSITO: Mueve a Gobs-Man a la celda en el borde hacia la direcci√≥n
// ‚Äúdirecci√≥n‚Äù. El cabezal queda sobre Gobs-Man.
// PRECONDICI√ìNES:
// * El cabezal se encuentra sobre Gobs-Man.
// PAR√ÅMETROS:
// * direcci√≥n: Direcci√≥n - Indica hacia d√≥nde se mover√° Gobs-Man.

// Ejercicio 1)
// Al comenzar un nuevo ‚Äúnivel‚Äù del juego, en cada celda del tablero hay un ‚Äúcoco‚Äù (peque√±os puntos amarillos)
// que son el alimento natural de los seres como Gobs-Man. El objetivo de Gobs-Man es precisamente comerse
// todos los cocos del nivel. Para poder hacer esto, contamos con la siguiente primitiva adicional a las
// anteriores:

// procedure ComerCoco()
// PROP√ìSITO: Come el coco que hay en la celda actual.
// PRECONDICIONES:
// * Hay un coco en la celda actual.
// * Gobs-Man est√° en la celda actual.

// Se desea implementar el procedimiento ComerTodosLosCocosDelNivel(), que hace que Gobs-Man se
// coma absolutamente todos los cocos del nivel (tablero). Sabemos, por precondici√≥n de dicho procedimiento,
// que hay un coco en cada celda del tablero (incluida en la que inicia Gobs-Man).

procedure ComerTodosLosCocosDelNivel() {
    /*
        PROP√ìSITO:
            * Hace que GosbMan coma absolutamente todos los cocos del nivel. 
        PRECONDICIONES:
            * GobsMan est√° en la celda actual.
            * Hay un coco en cada celda del tablero.
    */
    
    LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(Este, Norte)
    while (haySiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)) {
        ComerCoco()
        LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(Este, Norte)
    }
    ComerCoco()
}

procedure LlevarAGobsManALaPrimeraCeldaEnUnRecorridoAl_Y_(direcci√≥nPrincipal, direcci√≥nSecundaria) {
    /*
        PROP√ìSITO:
            * Lleva a GobsMan a la primera celda en un recorrido de direcciones **direcci√≥nPrincipal** y **direcci√≥nSecundaria**.
        PAR√ÅMETROS:
            * direcci√≥nPrincipal: Direcci√≥n
            * direcci√≥nSecundaria: Direcci√≥n
        PRECONDICIONES:
            * GobsMan debe estar en la celda actual.
    */
    LlevarGobsManAlBorde_(opuesto(direcci√≥nPrincipal))
    LlevarGobsManAlBorde_(opuesto(direcci√≥nSecundaria))
}

function myFunction(par√°metro1, par√°metro2) {
    /*
        PROP√ìSITO:
            * Indica si existe una celda siguiente en un recorrido de direcciones **direcci√≥nPrincipal** y **direcci√≥nSecundaria**.
        PAR√ÅMETROS:
            * direcci√≥nPrincipal: Direcci√≥n
            * direcci√≥nSecundaria: Direcci√≥n
        TIPO: Booleano.
        PRECONDICIONES:
            * No tiene (es una funci√≥n total).
    */
    
    return (puedeMover(direcci√≥nPrincipal) || puedeMover(direcci√≥nSecundaria))
}

procedure LlevarAGobsManALaSiguienteCeldaEnUnRecorridoAl_Y_(direcci√≥nPrincipal, direcci√≥nSecundaria) {
    /*
        PROP√ìSITO:
            * Lleva a GosbMan a la siguiente celda en un recorrido de direcciones **direcci√≥nPrincipal** y **direcci√≥nSecundaria**.
        PAR√ÅMETROS:
            * direcci√≥nPrincipal: Direcci√≥n
            * direcci√≥nSecundaria: Direcci√≥n
        PRECONDICIONES:
            * GosbMan est√° en la celda actual.
            * Debe existir una celda siguiente en el recorrido de direcciones dadas.
    */
    
    if(puedeMover(direcci√≥nPrincipal)){
        MoverGobsManAl_(direcci√≥nPrincipal)
    }
    else{
        LlevarGobsManAlBorde_(opuesto(direcci√≥nPrincipal))
        MoverGobsManAl_(direcci√≥nSecundaria)
    }
}